@using SchedulerMVP.Data
@using SchedulerMVP.Data.Entities
@using SchedulerMVP.Services
@using Microsoft.EntityFrameworkCore
@using Microsoft.EntityFrameworkCore.Infrastructure
@using Microsoft.JSInterop
@using System.Text.Json
@using System.Threading
@inject IDbContextFactory<AppDbContext> DbFactory
@inject UIState UI
@inject IJSRuntime JSRuntime
@inject IConflictService ConflictService
@inject ICalendarBookingService CalendarBookingService
@inject IScheduleTemplateService TemplateService
@inject IPlaceService PlaceService
@inject UserContextService UserContext
@implements IDisposable

<div class="week-grid-container">
    @* Navigation elements moved to TopBar *@

    @if (!UI.IsCalendarViewMode && UI.IsWeekListView)
    {
        <!-- List view for week planning -->
        <WeekListView />
    }
    else
    {
        <!-- Grid view (default) -->
        <div class="week-grid @(UI.IsDayView ? "day-view" : "")">
        <div class="time-gutter">
            <div class="time-header">
                <div class="time-name">&nbsp;</div>
                @if (UI.IsCalendarViewMode)
                {
                    <div class="time-date">&nbsp;</div>
                }
            </div>
            <div class="time-body">
                @for (int hour = 0; hour < 24; hour++)
                {
                    <div class="time-label" style="top: @(hour * 60)px">
                        @hour.ToString("00"):00
                    </div>
                }
            </div>
        </div>

        @if (UI.IsDayView)
        {
            // Day view: render exactly one column based on CurrentWeekStart
            var currentDayCapture = GetCurrentDayIndex();
                var dayDate = UI.CurrentWeekStart;
                var dayName = GetFullDayName(currentDayCapture);

                <div class="day-column">
                    <div class="day-header @(UI.IsCalendarViewMode && IsToday(dayDate) ? "today-highlight" : "")">
                        <div class="day-name">@dayName</div>
                        @if (UI.IsCalendarViewMode)
                        {
                            <div class="day-date">@FormatDayHeader(dayDate)</div>
                        }
                    </div>

                    <div class="day-content" 
                         data-day-index="@currentDayCapture"
                         @onclick="@((MouseEventArgs e) => OnDayContentClick(e, currentDayCapture))"
                         @onmousemove="@((MouseEventArgs e) => OnDayContentMouseMove(e, currentDayCapture))"
                         @onmouseleave="OnDayContentMouseLeave"
                         title="@GetTooltipText(currentDayCapture)">
                        
                        @if (!UI.IsCalendarViewMode)
                        {
                            @foreach (var positioned in GetPositionedBookingsForDay(currentDayCapture))
                            {
                                var template = (TemplateView)positioned.Booking;
                            var isPrimaryT = UI.IsGroupFilterActive ? true : (!positioned.IsGhost && (!UI.SelectedAreaId.HasValue || (UI.SelectedAreaId.HasValue && template.AreaId == UI.SelectedAreaId.Value)));
                                var clsT = isPrimaryT ? "booking-block booking--primary" : "booking-block"; // Add booking--primary class for draggable bookings
                                var templateCapture = template; // Capture for onclick
                                var posStyle = GetPositionStyle(positioned.WidthPercent, positioned.LeftPercent);
                                var colorStyle = GetBookingColorStyle(template, positioned.IsGhost);
                            var hideGhostText = positioned.IsGhost && positioned.WidthPercent < 35.0 && !UI.IsDayView; // always show text in day view
                                <div class="@clsT" 
                                     data-booking-id="@template.Id"
                                     data-booking-type="template"
                                     data-day="@template.DayOfWeek"
                                     data-start-min="@template.StartMin"
                                     data-end-min="@template.EndMin"
                                     style="top: @(template.StartMin)px; height: @(Math.Max(template.EndMin - template.StartMin, 15))px; @posStyle @colorStyle"
                                     title="@(isPrimaryT ? $"Klicka för att redigera {template.Group?.Name}" : $"{template.Group?.Name} ({template.SourceAreaName})")">
                                    @* Always render resize handles for ALL booking blocks *@
                                    <div class="resize-handle resize-handle-top" data-resize-type="start"></div>
                                    <div class="resize-handle resize-handle-bottom" data-resize-type="end"></div>
                                    <div class="@(positioned.IsGhost ? "ghost-content" : "booking-content")">
                                    @if (!hideGhostText)
                                    {
                                        <div class="booking-group">@template.Group?.Name</div>
                                        <div class="booking-time">@FormatTime(template.StartMin) - @FormatTime(template.EndMin)</div>
                                if (UI.IsGroupFilterActive)
                                {
                                    <div class="ghost-source">@GetPlaceAreaLabel(template)</div>
                                }
                                else if (positioned.IsGhost)
                                        {
                                            <div class="ghost-source">@template.SourceAreaName</div>
                                        }
                                        }
                                    </div>
                                </div>
                            }
                        }
                        else
                        {
                            @foreach (var positioned in GetPositionedCalendarForDay(dayDate))
                            {
                                var template = (TemplateView)positioned.Booking;
                                var isPrimary = UI.IsGroupFilterActive ? true : (!positioned.IsGhost && (!UI.SelectedAreaId.HasValue || (UI.SelectedAreaId.HasValue && template.AreaId == UI.SelectedAreaId.Value)));
                                var cls = isPrimary ? "booking-block booking--primary" : "booking-block"; // Add booking--primary class for draggable bookings
                                var posStyle = GetPositionStyle(positioned.WidthPercent, positioned.LeftPercent);
                                var colorStyle = GetBookingColorStyle(template, positioned.IsGhost);
                                var calBooking = weekBookings.FirstOrDefault(b => b.Id == template.Id);
                            var templateCapture = template; // Capture for onclick
                            var hideGhostText = positioned.IsGhost && positioned.WidthPercent < 35.0 && !UI.IsDayView; // always show text in day view
                                // Show place/area info when no area is selected (to distinguish bookings from different areas/places)
                                var showPlaceAreaInfo = !UI.SelectedAreaId.HasValue && !UI.SelectedPlaceId.HasValue && !UI.IsGroupFilterActive;
                                <div class="@cls" 
                                     data-booking-id="@template.Id"
                                     data-booking-type="@(calBooking != null ? "calendar" : "template")"
                                     data-day="@(calBooking != null && template.Date.HasValue ? template.Date.Value.ToString("yyyy-MM-dd") : template.DayOfWeek.ToString())"
                                     data-start-min="@template.StartMin"
                                     data-end-min="@template.EndMin"
                                     style="top: @(template.StartMin)px; height: @(Math.Max(template.EndMin - template.StartMin, 15))px; @posStyle @colorStyle"
                                     title="@(isPrimary ? $"Klicka för att redigera {template.Group?.Name}" : $"{template.Group?.Name} ({template.SourceAreaName})")">
                                    @* Always render resize handles for ALL booking blocks *@
                                    <div class="resize-handle resize-handle-top" data-resize-type="start"></div>
                                    <div class="resize-handle resize-handle-bottom" data-resize-type="end"></div>
                                    @* Published indicator - green check icon for primary, gray for ghost *@
                                    @if (template.Date.HasValue && template.Published)
                                    {
                                        @if (positioned.IsGhost)
                                        {
                                            <span class="material-symbols-outlined published-check-icon-ghost">check_circle</span>
                                        }
                                        else
                                        {
                                            <span class="material-symbols-outlined published-check-icon">check_circle</span>
                                        }
                                    }
                                    <div class="@(positioned.IsGhost ? "ghost-content" : "booking-content")">
                                    @if (!hideGhostText)
                                    {
                                        <div class="booking-group">@template.Group?.Name</div>
                                        <div class="booking-time">@FormatTime(template.StartMin) - @FormatTime(template.EndMin)</div>
                                        @if (UI.IsGroupFilterActive)
                                        {
                                            <div class="ghost-source">@GetPlaceAreaLabel(template)</div>
                                        }
                                        else if (positioned.IsGhost || showPlaceAreaInfo)
                                        {
                                            <div class="ghost-source">@template.SourceAreaName</div>
                                        }
                                        }
                                    </div>
                                </div>
                            }
                        }
                    </div>
                </div>
            }
            else
            {
                // Week view - show all 7 days
                @for (int day = 1; day <= 7; day++)
                {
                    var currentDayCapture = day; // Capture the loop variable
                    var dayDate = UI.CurrentWeekStart.AddDays(day - 1);
                    var dayName = GetDayName(day);

                <div class="day-column">
                    <div class="day-header @(UI.IsCalendarViewMode && IsToday(dayDate) ? "today-highlight" : "")">
                        <div class="day-name">@dayName</div>
                        @if (UI.IsCalendarViewMode)
                        {
                            <div class="day-date">@FormatDayHeader(dayDate)</div>
                        }
                    </div>

                    <div class="day-content" 
                         data-day-index="@currentDayCapture"
                         @onclick="@((MouseEventArgs e) => OnDayContentClick(e, currentDayCapture))"
                         @onmousemove="@((MouseEventArgs e) => OnDayContentMouseMove(e, currentDayCapture))"
                         @onmouseleave="OnDayContentMouseLeave"
                         title="@GetTooltipText(currentDayCapture)">
                        
                        @if (!UI.IsCalendarViewMode)
                        {
                            @foreach (var positioned in GetPositionedBookingsForDay(day))
                            {
                                var template = (TemplateView)positioned.Booking;
                                var isPrimaryT = UI.IsGroupFilterActive ? true : (!positioned.IsGhost && (!UI.SelectedAreaId.HasValue || (UI.SelectedAreaId.HasValue && template.AreaId == UI.SelectedAreaId.Value)));
                                var clsT = isPrimaryT ? "booking-block booking--primary" : "booking-block"; // Add booking--primary class for draggable bookings
                                var templateCapture = template; // Capture for onclick
                                var posStyle = GetPositionStyle(positioned.WidthPercent, positioned.LeftPercent);
                                var colorStyle = GetBookingColorStyle(template, positioned.IsGhost);
                            var hideGhostText = positioned.IsGhost && positioned.WidthPercent < 35.0 && !UI.IsDayView; // always show text in day view
                                <div class="@clsT" 
                                     data-booking-id="@template.Id"
                                     data-booking-type="template"
                                     data-day="@template.DayOfWeek"
                                     data-start-min="@template.StartMin"
                                     data-end-min="@template.EndMin"
                                     style="top: @(template.StartMin)px; height: @(Math.Max(template.EndMin - template.StartMin, 15))px; @posStyle @colorStyle"
                                     title="@(isPrimaryT ? $"Klicka för att redigera {template.Group?.Name}" : $"{template.Group?.Name} ({template.SourceAreaName})")">
                                    @* Always render resize handles for ALL booking blocks *@
                                    <div class="resize-handle resize-handle-top" data-resize-type="start"></div>
                                    <div class="resize-handle resize-handle-bottom" data-resize-type="end"></div>
                                    <div class="@(positioned.IsGhost ? "ghost-content" : "booking-content")">
                                    @if (!hideGhostText)
                                    {
                                        <div class="booking-group">@template.Group?.Name</div>
                                        <div class="booking-time">@FormatTime(template.StartMin) - @FormatTime(template.EndMin)</div>
                                if (UI.IsGroupFilterActive)
                                {
                                    <div class="ghost-source">@GetPlaceAreaLabel(template)</div>
                                }
                                else if (positioned.IsGhost)
                                        {
                                            <div class="ghost-source">@template.SourceAreaName</div>
                                        }
                                        }
                                    </div>
                                </div>
                            }
                        }
                        else
                        {
                            @foreach (var positioned in GetPositionedCalendarForDay(dayDate))
                            {
                                var template = (TemplateView)positioned.Booking;
                                var isPrimary = UI.IsGroupFilterActive ? true : (!positioned.IsGhost && (!UI.SelectedAreaId.HasValue || (UI.SelectedAreaId.HasValue && template.AreaId == UI.SelectedAreaId.Value)));
                                var cls = isPrimary ? "booking-block booking--primary" : "booking-block"; // Add booking--primary class for draggable bookings
                                var posStyle = GetPositionStyle(positioned.WidthPercent, positioned.LeftPercent);
                                var colorStyle = GetBookingColorStyle(template, positioned.IsGhost);
                                var calBooking = weekBookings.FirstOrDefault(b => b.Id == template.Id);
                            var templateCapture = template; // Capture for onclick
                            var hideGhostText = positioned.IsGhost && positioned.WidthPercent < 35.0 && !UI.IsDayView; // always show text in day view
                                // Show place/area info when no area is selected (to distinguish bookings from different areas/places)
                                var showPlaceAreaInfo = !UI.SelectedAreaId.HasValue && !UI.SelectedPlaceId.HasValue && !UI.IsGroupFilterActive;
                                <div class="@cls" 
                                     data-booking-id="@template.Id"
                                     data-booking-type="@(calBooking != null ? "calendar" : "template")"
                                     data-day="@(calBooking != null && template.Date.HasValue ? template.Date.Value.ToString("yyyy-MM-dd") : template.DayOfWeek.ToString())"
                                     data-start-min="@template.StartMin"
                                     data-end-min="@template.EndMin"
                                     style="top: @(template.StartMin)px; height: @(Math.Max(template.EndMin - template.StartMin, 15))px; @posStyle @colorStyle"
                                     title="@(isPrimary ? $"Klicka för att redigera {template.Group?.Name}" : $"{template.Group?.Name} ({template.SourceAreaName})")">
                                    @* Always render resize handles for ALL booking blocks *@
                                    <div class="resize-handle resize-handle-top" data-resize-type="start"></div>
                                    <div class="resize-handle resize-handle-bottom" data-resize-type="end"></div>
                                    @* Published indicator - green check icon in top right corner *@
                                    @if (template.Date.HasValue && template.Published)
                                    {
                                        <span class="material-symbols-outlined published-check-icon">check_circle</span>
                                    }
                                    <div class="@(positioned.IsGhost ? "ghost-content" : "booking-content")">
                                    @if (!hideGhostText)
                                    {
                                        <div class="booking-group">@template.Group?.Name</div>
                                        <div class="booking-time">@FormatTime(template.StartMin) - @FormatTime(template.EndMin)</div>
                                        @if (UI.IsGroupFilterActive)
                                        {
                                            <div class="ghost-source">@GetPlaceAreaLabel(template)</div>
                                        }
                                        else if (positioned.IsGhost || showPlaceAreaInfo)
                                        {
                                            <div class="ghost-source">@template.SourceAreaName</div>
                                        }
                                        }
                                    </div>
                                </div>
                            }
                        }
                    </div>
                </div>
                }
            }
        }
    </div>
    }
</div>

@if (popoverOpen && (popoverBooking != null || popoverTemplate != null))
{
    var areaName = popoverBooking?.Area?.Name ?? popoverTemplate?.Area?.Name ?? "Okänd area";
    var groupName = popoverBooking?.Group?.Name ?? popoverTemplate?.Group?.Name ?? "Okänd grupp";
    var startMin = popoverBooking?.StartMin ?? popoverTemplate?.StartMin ?? 0;
    var endMin = popoverBooking?.EndMin ?? popoverTemplate?.EndMin ?? 0;
    var notes = popoverBooking?.Notes ?? popoverTemplate?.Notes;
    var contactName = popoverBooking?.ContactName ?? popoverTemplate?.ContactName;
    var contactPhone = popoverBooking?.ContactPhone ?? popoverTemplate?.ContactPhone;
    var contactEmail = popoverBooking?.ContactEmail ?? popoverTemplate?.ContactEmail;
    
    // Format time and day/date on same line
    var timeAndDay = popoverBooking != null 
        ? $"{popoverBooking.Date.ToString("yyyy-MM-dd")} {FormatTime(startMin)} – {FormatTime(endMin)}"
        : $"{GetFullDayName(popoverTemplate?.DayOfWeek ?? 1)} {FormatTime(startMin)} – {FormatTime(endMin)}";
    
    <div @onclick:stopPropagation="true" style="position:fixed; left:@(popoverX)px; top:@(popoverY)px; transform: translate(8px, 8px); background:#fff; border:1px solid #e5e7eb; border-radius:12px; box-shadow:0 10px 24px rgba(16,24,40,.18); width:320px; z-index:5000;">
        @* Published indicator - green check icon in top right corner *@
        @if (popoverBooking != null && popoverBooking.Published)
        {
            <span class="material-symbols-outlined" style="position:absolute; top:12px; right:12px; font-size:20px; color:#16a34a; z-index:10;">check_circle</span>
        }
        <div style="display:flex; align-items:center; padding:12px 14px; border-bottom:1px solid #eef2f7;">
            <div style="font-size:16px; font-weight:600; color:#0b1e34; flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">@areaName</div>
            <div style="display:flex; gap:4px;">
                <button @onclick="EditFromPopover" style="border:none; background:#f8fafc; color:#475569; width:32px; height:32px; border-radius:6px; display:flex; align-items:center; justify-content:center; cursor:pointer; transition:all 0.2s;" title="Redigera">
                    <span class="material-symbols-outlined" style="font-size:18px;">edit</span>
                </button>
                <button @onclick="DeleteFromPopover" style="border:none; background:#f8fafc; color:#475569; width:32px; height:32px; border-radius:6px; display:flex; align-items:center; justify-content:center; cursor:pointer; transition:all 0.2s;" title="Ta bort">
                    <span class="material-symbols-outlined" style="font-size:18px;">delete</span>
                </button>
                <button @onclick="ClosePopover" style="border:none; background:transparent; color:#94a3b8; width:32px; height:32px; border-radius:6px; display:flex; align-items:center; justify-content:center; cursor:pointer; transition:all 0.2s;" title="Stäng">
                    <span class="material-symbols-outlined" style="font-size:20px;">close</span>
                </button>
            </div>
        </div>
        <div style="padding:12px 14px; display:flex; flex-direction:column; gap:8px; color:#0b1e34;">
            <div style="font-size:14px; font-weight:600; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">@groupName</div>
            <div style="font-size:13px; color:#475569;">@timeAndDay</div>
            @if (!string.IsNullOrWhiteSpace(notes))
            {
                <div style="font-size:12px; color:#334155; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">@notes</div>
            }
            @if (!string.IsNullOrWhiteSpace(contactName))
            {
                <div style="font-size:12px; color:#334155; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">@contactName</div>
            }
            @if (!string.IsNullOrWhiteSpace(contactPhone) || !string.IsNullOrWhiteSpace(contactEmail))
            {
                <div style="font-size:12px; color:#334155; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
                    @contactPhone@if(!string.IsNullOrWhiteSpace(contactPhone) && !string.IsNullOrWhiteSpace(contactEmail)){<text> • </text>}@contactEmail
                </div>
            }
        </div>
    </div>
    <div @onclick="ClosePopover" style="position:fixed; inset:0; z-index:4999; background:transparent;"></div>
}
@code {
    private List<TemplateView> allTemplates = new();
    private List<Group> groups = new();
    private List<CalendarBooking> weekBookings = new();
    private Area? selectedArea;
    private Place? selectedPlace;
    
    private void LogDebug(string location, string message, object? data = null, string? hypothesisId = null)
    {
        try
        {
            var logEntry = new { location, message, data, timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(), sessionId = "debug-session", runId = "run1", hypothesisId };
            var logJson = System.Text.Json.JsonSerializer.Serialize(logEntry);
            // Write to console (visible in Azure App Service logs)
            Console.WriteLine($"[DEBUG] {logJson}");
            // Also try to write to file if possible (for local debugging)
            try
            {
                var logPath = System.IO.Path.Combine(System.Environment.GetEnvironmentVariable("HOME") ?? ".", ".cursor", "debug.log");
                System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(logPath)!);
                System.IO.File.AppendAllText(logPath, logJson + "\n");
            }
            catch { }
        }
        catch { }
    }
    private bool _didInitialScroll;
    private int? _tooltipDay;
    private double _tooltipMouseY;
    private string _tooltipText = "";
    
    // Drag and Drop
    private DotNetObjectReference<WeekGrid>? _dotNetRef;
    private bool _dragDropInitialized = false;
    
    // Cache for all areas to avoid syncing DbContext calls
    private Dictionary<Guid, Area> areaCache = new();
    // Cache for leaf counts per area
    private Dictionary<Guid, int> areaLeafCountCache = new();
    // Cache for sorting order per area based on linked leaf SortOrder (min)
    private Dictionary<Guid, int> areaSortOrderCache = new();
    private int selectedAreaTotalLeafs = 0;

    public sealed class TemplateView : BookingTemplate 
    { 
        public bool IsGhost { get; set; } 
        public string SourceAreaName { get; set; } = string.Empty;
        public Guid? SourceTemplateId { get; set; }
        public BookingTemplate? SourceTemplate { get; set; }
        public double WidthPercent { get; set; } = 100;
        public double LeftPercent { get; set; } = 0;
        public DateOnly? Date { get; set; } // For calendar bookings
        public bool Published { get; set; } // For calendar bookings - published status
        public DateTime? PublishedAt { get; set; } // For calendar bookings - published timestamp
    }
    
    public class PositionedBooking
    {
        public object Booking { get; set; } = null!; // Can be TemplateView or CalendarBooking
        public bool IsGhost { get; set; }
        public double WidthPercent { get; set; }
        public double LeftPercent { get; set; }
        public int LeafCount { get; set; }
    }

    // PERF: Track last loaded state to avoid unnecessary reloads
    private Guid? _lastLoadedAreaId;
    private Guid? _lastLoadedTemplateId;
    private bool _lastLoadedCalendarMode;
    private DateOnly _lastLoadedWeekStart;
    private Guid? _lastLoadedFilteredGroupId;
    
    // CRITICAL FIX: Semaphore to prevent concurrent LoadDataAsync execution (race condition fix)
    // When UI.OnChanged fires multiple times in rapid succession (e.g., when multiple properties change),
    // multiple LoadDataAsync calls can run simultaneously, causing data to be overwritten incorrectly
    private readonly SemaphoreSlim _loadDataLock = new SemaphoreSlim(1, 1);
    
    protected override async Task OnInitializedAsync()
    {
        UI.OnChanged += async () => 
        { 
            try
            {
                // #region agent log
                LogDebug("WeekGrid.razor:401", "OnChanged triggered", new { selectedAreaId = UI.SelectedAreaId?.ToString(), selectedTemplateId = UI.SelectedTemplateId?.ToString(), isCalendarViewMode = UI.IsCalendarViewMode, isWeekListView = UI.IsWeekListView, isDayView = UI.IsDayView, isResourceView = UI.IsResourceView, currentWeekStart = UI.CurrentWeekStart.ToString(), filteredGroupId = UI.FilteredGroupId?.ToString() }, "A");
                // #endregion
                // PERF: Only reload if relevant state actually changed
                var areaChanged = _lastLoadedAreaId != UI.SelectedAreaId;
                var templateChanged = _lastLoadedTemplateId != UI.SelectedTemplateId;
                var viewModeChanged = _lastLoadedCalendarMode != UI.IsCalendarViewMode;
                var weekChanged = _lastLoadedWeekStart != UI.CurrentWeekStart;
                var groupFilterChanged = _lastLoadedFilteredGroupId != UI.FilteredGroupId;
                
                // #region agent log
                LogDebug("WeekGrid.razor:414", "Change detection result", new { areaChanged, templateChanged, viewModeChanged, weekChanged, groupFilterChanged, forceRefresh = UI.ForceRefresh, shouldReload = areaChanged || templateChanged || viewModeChanged || weekChanged || groupFilterChanged || UI.ForceRefresh }, "A");
                // #endregion
                // Always reload if state changed OR if force refresh is requested
                // This ensures new bookings appear immediately
                if (areaChanged || templateChanged || viewModeChanged || weekChanged || groupFilterChanged || UI.ForceRefresh)
                {
                    // CRITICAL FIX: Use semaphore to prevent concurrent LoadDataAsync execution
                    // This fixes race conditions where multiple OnChanged events fire in rapid succession
                    await _loadDataLock.WaitAsync();
                    try
                    {
                        // #region agent log
                        LogDebug("WeekGrid.razor:416", "Calling LoadDataAsync (locked)", null, "B");
                        // #endregion
                        await LoadDataAsync();
                        // #region agent log
                        LogDebug("WeekGrid.razor:417", "LoadDataAsync completed, calling StateHasChanged", new { allTemplatesCount = allTemplates?.Count ?? 0, weekBookingsCount = weekBookings?.Count ?? 0 }, "B");
                        // #endregion
                        _lastLoadedAreaId = UI.SelectedAreaId;
                        _lastLoadedTemplateId = UI.SelectedTemplateId;
                        _lastLoadedCalendarMode = UI.IsCalendarViewMode;
                        _lastLoadedWeekStart = UI.CurrentWeekStart;
                        _lastLoadedFilteredGroupId = UI.FilteredGroupId;
                        UI.ForceRefresh = false; // Reset flag after reload
                        await InvokeAsync(StateHasChanged);
                        // #region agent log
                        LogDebug("WeekGrid.razor:423", "StateHasChanged completed", null, "B");
                        // #endregion
                    }
                    finally
                    {
                        _loadDataLock.Release();
                    }
                }
            }
            catch (Exception ex)
            {
                // #region agent log
                LogDebug("WeekGrid.razor:428", "OnChanged error", new { error = ex.Message, stack = ex.StackTrace }, "A");
                // #endregion
                // Silently handle errors to prevent circuit crashes
            }
        };
        // Ensure templates (and SelectedTemplateId) are available before the first data load
        try
        {
            await LoadTemplates();
            await LoadDataAsync();
        }
        catch (Exception ex)
        {
            // Handle initialization errors gracefully
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_didInitialScroll)
        {
            try
            {
                // 08:00 => 8 * 60 = 480px
                await JSRuntime.InvokeVoidAsync("SchedulerMVP.scrollToPos", 480);
            }
            catch { }
            _didInitialScroll = true;
        }
        
        // Initialize drag and drop - reuse DotNetObjectReference to avoid disposal issues
        try
        {
            // Only create new reference if it doesn't exist or was disposed
            if (_dotNetRef == null)
            {
                _dotNetRef = DotNetObjectReference.Create(this);
            }
            
            if (!_dragDropInitialized)
            {
                // CRITICAL: In production, DOM elements may not exist immediately after OnAfterRenderAsync
                // ResourceView uses Task.Delay(500) - we'll do similar but let initDragDrop handle retries
                if (firstRender)
                {
                    // Wait a bit longer on first render to ensure DOM is ready (especially in production)
                    await Task.Delay(300);
                }
                
                // Wait for both Blazor to be ready AND SchedulerMVP object to exist
                var maxWait = 10; // Reduced from 15 - initDragDrop will handle DOM retries
                var attempt = 0;
                while (attempt < maxWait)
                {
                    try
                    {
                        // Check if Blazor is ready AND SchedulerMVP exists
                        var isReady = await JSRuntime.InvokeAsync<bool>("eval", 
                            "typeof Blazor !== 'undefined' && " +
                            "typeof SchedulerMVP !== 'undefined' && " +
                            "typeof SchedulerMVP.initDragDrop === 'function'");
                        
                        if (isReady)
                        {
                            // Now initialize - initDragDrop will handle DOM readiness internally
                            await JSRuntime.InvokeVoidAsync("SchedulerMVP.initDragDrop", _dotNetRef);
                            _dragDropInitialized = true;
                            Console.WriteLine($"[WeekGrid] Drag and drop initialization started (attempt {attempt + 1})");
                            break;
                        }
                    }
                    catch (Exception ex)
                    {
                        // Not ready yet, wait and retry
                        Console.WriteLine($"[WeekGrid] JS not ready yet (attempt {attempt + 1}): {ex.Message}");
                    }
                    
                    attempt++;
                    if (attempt < maxWait)
                    {
                        await Task.Delay(200); // Wait 200ms between attempts
                    }
                }
                
                if (!_dragDropInitialized)
                {
                    Console.WriteLine("[WeekGrid] Warning: Failed to initialize drag and drop - JS not available");
                }
            }
            else
            {
                // CRITICAL: Only refresh drag and drop if NOT currently dragging
                // This prevents removing event listeners while user is dragging
                try
                {
                    var isDragging = await JSRuntime.InvokeAsync<bool>("SchedulerMVP.isDragging");
                    if (!isDragging)
                    {
                        // Refresh drag and drop after DOM updates - reuse same reference
                        await JSRuntime.InvokeVoidAsync("SchedulerMVP.refreshDragDrop", _dotNetRef);
                    }
                }
                catch
                {
                    // If isDragging check fails, refresh anyway (fallback)
                    await JSRuntime.InvokeVoidAsync("SchedulerMVP.refreshDragDrop", _dotNetRef);
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error initializing/refreshing drag and drop: {ex.Message}");
            Console.WriteLine($"Stack trace: {ex.StackTrace}");
            // If reference is invalid, create a new one
            if (_dotNetRef != null)
            {
                try
                {
                    _dotNetRef.Dispose();
                }
                catch { }
                _dotNetRef = null;
            }
        }
    }

    // PERF: Cache areas per place to avoid loading ALL areas every time
    private Dictionary<Guid, Dictionary<Guid, Area>> _areasByPlaceCache = new();
    private DateTime _areasCacheExpiry = DateTime.MinValue;
    private const int AREAS_CACHE_TTL_SECONDS = 60; // Cache for 60 seconds
    
    private async Task LoadDataAsync()
    {
        try
        {
        // #region agent log
        LogDebug("WeekGrid.razor:579", "LoadDataAsync entry", new { selectedAreaId = UI.SelectedAreaId?.ToString(), selectedPlaceId = UI.SelectedPlaceId?.ToString(), selectedTemplateId = UI.SelectedTemplateId?.ToString(), isCalendarViewMode = UI.IsCalendarViewMode, isGroupFilterActive = UI.IsGroupFilterActive, filteredGroupId = UI.FilteredGroupId?.ToString() }, "D");
        // #endregion
        // PERF: Only load areas for selected place, not ALL areas (unless group filter overrides)
        await using var db = await DbFactory.CreateDbContextAsync();
        
        var skipPlacePrefetch = UI.IsGroupFilterActive && !UI.IsCalendarViewMode;
        var cacheExpired = DateTime.UtcNow > _areasCacheExpiry;
        
        if (skipPlacePrefetch)
        {
            // Gruppfilter: vi hanterar areaCache senare baserat på gruppens bokningar
            areaCache.Clear();
            selectedArea = null;
            selectedPlace = null;
        }
        else
        {
            if (UI.SelectedPlaceId.HasValue)
            {
                // Load areas for selected place only (much faster)
                if (!_areasByPlaceCache.TryGetValue(UI.SelectedPlaceId.Value, out var placeAreas) || cacheExpired)
                {
                    placeAreas = await db.Areas
                        .Where(a => a.PlaceId == UI.SelectedPlaceId.Value)
                        .Include(a => a.Place)
                        .AsNoTracking()
                        .ToDictionaryAsync(a => a.Id, a => a);
                    _areasByPlaceCache[UI.SelectedPlaceId.Value] = placeAreas;
                    _areasCacheExpiry = DateTime.UtcNow.AddSeconds(AREAS_CACHE_TTL_SECONDS);
                }
                
                // Update areaCache from place-specific cache
                areaCache.Clear();
                foreach (var area in placeAreas.Values)
                {
                    areaCache[area.Id] = area;
                }
            }
            else
            {
                // Only load all areas if no place selected (shouldn't happen often)
                if (cacheExpired || areaCache.Count == 0)
                {
                    var allAreas = await db.Areas
                        .Include(a => a.Place)
                        .AsNoTracking()
                        .ToListAsync();
                    
                    areaCache.Clear();
                    foreach (var area in allAreas)
                    {
                        areaCache[area.Id] = area;
                    }
                    _areasCacheExpiry = DateTime.UtcNow.AddSeconds(AREAS_CACHE_TTL_SECONDS);
                }
            }
            
            if (UI.SelectedAreaId.HasValue)
            {
                selectedArea = areaCache.TryGetValue(UI.SelectedAreaId.Value, out var sa) ? sa : null;
                selectedPlace = selectedArea?.Place;
            }
            else
            {
                selectedArea = null;
                selectedPlace = null;
            }
        }

            // CRITICAL: Use async version to avoid blocking and improve performance
            var currentUserId = await UserContext.GetCurrentUserIdAsync();
            var currentIsAdmin = await UserContext.IsAdminAsync();

        if (!UI.IsCalendarViewMode)
        {
            // Veckoschema: load templates for selected schedule template with ghost logic
            if (UI.IsGroupFilterActive && UI.FilteredGroupId.HasValue)
            {
                // Multi-group filter: show all templates for selected groups
                selectedArea = null;
                selectedPlace = null;

                var filteredGroupId = UI.FilteredGroupId.Value;

                Guid templateId = UI.SelectedTemplateId ?? Guid.Empty;
                if (templateId == Guid.Empty)
                {
                    var templateQuery = db.ScheduleTemplates
                        .Where(t => t.Bookings.Any(bt => bt.GroupId == filteredGroupId));
                    
                    // Filter by user ownership
                    if (!currentIsAdmin && !string.IsNullOrEmpty(currentUserId))
                    {
                        templateQuery = templateQuery.Where(t => t.UserId == currentUserId);
                    }
                    
                    templateId = await templateQuery
                        .Select(t => t.Id)
                        .FirstOrDefaultAsync();

                    if (templateId != Guid.Empty)
                    {
                        UI.SelectedTemplateId = templateId;
                    }
                }
                else
                {
                    // Verify template ownership before checking if it contains the group
                    var templateOwnershipQuery = db.ScheduleTemplates.Where(t => t.Id == templateId);
                    if (!currentIsAdmin && !string.IsNullOrEmpty(currentUserId))
                    {
                        templateOwnershipQuery = templateOwnershipQuery.Where(t => t.UserId == currentUserId);
                    }
                    var templateExists = await templateOwnershipQuery.AnyAsync();
                    
                    if (!templateExists)
                    {
                        // Template doesn't exist or user doesn't have access, reset selection
                        templateId = Guid.Empty;
                        UI.SelectedTemplateId = null;
                    }
                    else
                    {
                        var templateContainsGroup = await db.BookingTemplates
                            .AnyAsync(bt => bt.ScheduleTemplateId == templateId && bt.GroupId == filteredGroupId);

                        if (!templateContainsGroup)
                        {
                            var templateQuery = db.ScheduleTemplates
                                .Where(t => t.Bookings.Any(bt => bt.GroupId == filteredGroupId));
                            
                            // Filter by user ownership
                            if (!currentIsAdmin && !string.IsNullOrEmpty(currentUserId))
                            {
                                templateQuery = templateQuery.Where(t => t.UserId == currentUserId);
                            }
                            
                            templateId = await templateQuery
                                .Select(t => t.Id)
                                .FirstOrDefaultAsync();

                            if (templateId != Guid.Empty)
                            {
                                UI.SelectedTemplateId = templateId;
                            }
                        }
                    }
                }

                if (templateId == Guid.Empty)
                {
                    allTemplates = new List<TemplateView>();
                    weekBookings = new List<CalendarBooking>();
                }
                else
                {
                    var templateQuery = db.ScheduleTemplates
                        .AsNoTracking()
                        .Include(t => t.Bookings)
                            .ThenInclude(bt => bt.Area)
                                .ThenInclude(a => a.Place)
                        .Include(t => t.Bookings)
                            .ThenInclude(bt => bt.Group)
                        .Where(t => t.Id == templateId);
                    
                    // Filter by user ownership
                    if (!currentIsAdmin && !string.IsNullOrEmpty(currentUserId))
                    {
                        templateQuery = templateQuery.Where(t => t.UserId == currentUserId);
                    }
                    
                    var templateEntity = await templateQuery.FirstOrDefaultAsync();

                    if (templateEntity == null)
                    {
                        allTemplates = new List<TemplateView>();
                        weekBookings = new List<CalendarBooking>();
                    }
                    else
                    {
                        var groupTemplates = templateEntity.Bookings
                            .Where(bt => bt.GroupId == filteredGroupId)
                            .ToList();
                        
                        if (!currentIsAdmin && !string.IsNullOrEmpty(currentUserId))
                        {
                            groupTemplates = groupTemplates
                                .Where(bt => bt.Group != null && bt.Group.UserId == currentUserId)
                                .ToList();
                        }

                        areaCache.Clear();
                        foreach (var bt in groupTemplates)
                        {
                            if (bt.Area != null)
                            {
                                areaCache[bt.Area.Id] = bt.Area;
                            }
                        }

                        allTemplates = groupTemplates.Select(bt => new TemplateView
                        {
                            Id = bt.Id,
                            AreaId = bt.AreaId,
                            GroupId = bt.GroupId,
                            DayOfWeek = bt.DayOfWeek,
                            StartMin = bt.StartMin,
                            EndMin = bt.EndMin,
                            Notes = bt.Notes,
                            Group = bt.Group,
                            Area = bt.Area,
                            IsGhost = false,
                            SourceAreaName = bt.Area?.Place != null
                                ? $"{bt.Area.Place.Name} - {bt.Area.Name}"
                                : bt.Area != null ? bt.Area.Name ?? "Okänd yta" : "Okänd plats"
                        }).ToList();

                        weekBookings = new List<CalendarBooking>();
                    }
                }
            }
            else if (UI.IsGroupFilterActive && UI.FilteredGroupId.HasValue)
            {
                selectedArea = null;
                selectedPlace = null;

                var filteredGroupId = UI.FilteredGroupId.Value;

                Guid templateId = UI.SelectedTemplateId ?? Guid.Empty;
                if (templateId == Guid.Empty)
                {
                    var templateQuery = db.ScheduleTemplates
                        .Where(t => t.Bookings.Any(bt => bt.GroupId == filteredGroupId));
                    
                    // Filter by user ownership
                    if (!currentIsAdmin && !string.IsNullOrEmpty(currentUserId))
                    {
                        templateQuery = templateQuery.Where(t => t.UserId == currentUserId);
                    }
                    
                    templateId = await templateQuery
                        .Select(t => t.Id)
                        .FirstOrDefaultAsync();

                    if (templateId != Guid.Empty)
                    {
                        UI.SelectedTemplateId = templateId;
                    }
                }
                else
                {
                    // Verify template ownership before checking if it contains the group
                    var templateOwnershipQuery = db.ScheduleTemplates.Where(t => t.Id == templateId);
                    if (!currentIsAdmin && !string.IsNullOrEmpty(currentUserId))
                    {
                        templateOwnershipQuery = templateOwnershipQuery.Where(t => t.UserId == currentUserId);
                    }
                    var templateExists = await templateOwnershipQuery.AnyAsync();
                    
                    if (!templateExists)
                    {
                        // Template doesn't exist or user doesn't have access, reset selection
                        templateId = Guid.Empty;
                        UI.SelectedTemplateId = null;
                    }
                    else
                    {
                        var templateContainsGroup = await db.BookingTemplates
                            .AnyAsync(bt => bt.ScheduleTemplateId == templateId && bt.GroupId == filteredGroupId);

                        if (!templateContainsGroup)
                        {
                            var templateQuery = db.ScheduleTemplates
                                .Where(t => t.Bookings.Any(bt => bt.GroupId == filteredGroupId));
                            
                            // Filter by user ownership
                            if (!currentIsAdmin && !string.IsNullOrEmpty(currentUserId))
                            {
                                templateQuery = templateQuery.Where(t => t.UserId == currentUserId);
                            }
                            
                            templateId = await templateQuery
                                .Select(t => t.Id)
                                .FirstOrDefaultAsync();

                            if (templateId != Guid.Empty)
                            {
                                UI.SelectedTemplateId = templateId;
                            }
                        }
                    }
                }

                if (templateId == Guid.Empty)
                {
                    allTemplates = new List<TemplateView>();
                    weekBookings = new List<CalendarBooking>();
                }
                else
                {
                    var templateQuery = db.ScheduleTemplates
                        .AsNoTracking()
                        .Include(t => t.Bookings)
                            .ThenInclude(bt => bt.Area)
                                .ThenInclude(a => a.Place)
                        .Include(t => t.Bookings)
                            .ThenInclude(bt => bt.Group)
                        .Where(t => t.Id == templateId);
                    
                    // Filter by user ownership
                    if (!currentIsAdmin && !string.IsNullOrEmpty(currentUserId))
                    {
                        templateQuery = templateQuery.Where(t => t.UserId == currentUserId);
                    }
                    
                    var templateEntity = await templateQuery.FirstOrDefaultAsync();

                    if (templateEntity == null)
                    {
                        allTemplates = new List<TemplateView>();
                        weekBookings = new List<CalendarBooking>();
                    }
                    else
                    {
                        var groupTemplates = templateEntity.Bookings
                            .Where(bt => bt.GroupId == filteredGroupId)
                            .ToList();
                        
                        // Additional filter: ensure group belongs to current user
                        if (!currentIsAdmin && !string.IsNullOrEmpty(currentUserId))
                        {
                            groupTemplates = groupTemplates
                                .Where(bt => bt.Group != null && bt.Group.UserId == currentUserId)
                                .ToList();
                        }

                        areaCache.Clear();
                        foreach (var bt in groupTemplates)
                        {
                            if (bt.Area != null)
                            {
                                areaCache[bt.Area.Id] = bt.Area;
                            }
                        }

                        allTemplates = groupTemplates.Select(bt => new TemplateView
                        {
                            Id = bt.Id,
                            AreaId = bt.AreaId,
                            GroupId = bt.GroupId,
                            DayOfWeek = bt.DayOfWeek,
                            StartMin = bt.StartMin,
                            EndMin = bt.EndMin,
                            Notes = bt.Notes,
                            Group = bt.Group,
                            Area = bt.Area,
                            IsGhost = false,
                            SourceAreaName = bt.Area?.Place != null
                                ? $"{bt.Area.Place.Name} - {bt.Area.Name}"
                                : bt.Area != null ? bt.Area.Name ?? "Okänd yta" : "Okänd plats"
                        }).ToList();

                        weekBookings = new List<CalendarBooking>();
                    }
                }
            }
                else if (UI.SelectedTemplateId.HasValue)
                {
                    var templateId = UI.SelectedTemplateId.Value;

                    if (UI.SelectedAreaId.HasValue && selectedArea != null)
                    {
                        // PERF: Use cached area IDs from areaCache instead of querying DB again
                        var allPlaceAreaIds = areaCache.Values
                            .Where(a => a.PlaceId == selectedArea.PlaceId)
                            .Select(a => a.Id)
                            .ToList();
                        
                        // Pre-load leaf counts for all areas (in parallel with template query)
                        var leafCountTask = LoadLeafCountCacheAsync(allPlaceAreaIds);

                        var overlappingTemplatesQuery = db.BookingTemplates
                            .Where(bt => bt.ScheduleTemplateId == templateId && allPlaceAreaIds.Contains(bt.AreaId))
                            .Include(bt => bt.Group)
                            .Include(bt => bt.Area)
                            .ThenInclude(a => a.Place)
                            .AsNoTracking();

                        if (!currentIsAdmin && !string.IsNullOrEmpty(currentUserId))
                        {
                            overlappingTemplatesQuery = overlappingTemplatesQuery.Where(bt => bt.Group!.UserId == currentUserId);
                        }

                        // PERF: Run leaf count and template query in parallel
                        var templateTask = overlappingTemplatesQuery.ToListAsync();
                        await Task.WhenAll(leafCountTask, templateTask);
                        var overlappingTemplates = await templateTask;

                        // Convert to TemplateView with ghost logic
                        var templateViews = new List<TemplateView>();
                        foreach (var bt in overlappingTemplates)
                        {
                            var isGhost = false;
                            if (bt.AreaId != selectedArea.Id)
                            {
                                // Check if this template should show as ghost using hierarchy logic
                                isGhost = ShouldShowAsGhost(selectedArea, bt.Area);
                            }

                            templateViews.Add(new TemplateView
                            {
                                Id = bt.Id,
                                AreaId = bt.AreaId,
                                GroupId = bt.GroupId,
                                DayOfWeek = bt.DayOfWeek,
                                StartMin = bt.StartMin,
                                EndMin = bt.EndMin,
                                Notes = bt.Notes,
                                Group = bt.Group,
                                Area = bt.Area,
                                IsGhost = isGhost,
                                SourceAreaName = $"{bt.Area?.Name ?? "Okänd yta"}"
                            });
                        }

                        allTemplates = templateViews;
                    }
                    else
                    {
                        // Load templates normally when no specific area is selected
                        var query = db.BookingTemplates.Where(bt => bt.ScheduleTemplateId == templateId);

                        if (UI.SelectedPlaceId.HasValue)
                        {
                            var placeAreaIds = await db.Areas
                                .Where(a => a.PlaceId == UI.SelectedPlaceId.Value)
                                .Select(a => a.Id)
                                .ToListAsync();
                            query = query.Where(bt => placeAreaIds.Contains(bt.AreaId));
                        }

                        if (!currentIsAdmin && !string.IsNullOrEmpty(currentUserId))
                        {
                            query = query.Where(bt => bt.Group!.UserId == currentUserId);
                        }

                        var templates = await query
                            .Include(bt => bt.Group)
                            .Include(bt => bt.Area)
                            .ThenInclude(a => a.Place)
                            .AsNoTracking()
                            .ToListAsync();

                        allTemplates = templates.Select(t => new TemplateView
                        {
                            Id = t.Id,
                            AreaId = t.AreaId,
                            GroupId = t.GroupId,
                            DayOfWeek = t.DayOfWeek,
                            StartMin = t.StartMin,
                            EndMin = t.EndMin,
                            Notes = t.Notes,
                            Group = t.Group,
                            Area = t.Area,
                            IsGhost = false,
                            SourceAreaName = $"{t.Area?.Place?.Name ?? "Okänd plats"} - {t.Area?.Name ?? "Okänd yta"}"
                        }).ToList();
                    }
                }
                else
                {
                    allTemplates = new List<TemplateView>();
                }
                weekBookings = new List<CalendarBooking>();
            }
            else if (UI.IsGroupFilterActive && UI.FilteredGroupId.HasValue)
            {
                // Single group filter: visa alla bokningar för den valda gruppen
                var weekStart = UI.CurrentWeekStart;
                var weekEnd = UI.CurrentWeekEnd;

                var groupBookingsQuery = db.CalendarBookings
                    .Where(c => c.Date >= weekStart && c.Date <= weekEnd && c.GroupId == UI.FilteredGroupId.Value)
                    .Include(c => c.Group)
                    .Include(c => c.Area)
                    .ThenInclude(a => a.Place)
                    .AsNoTracking();

                if (!currentIsAdmin && !string.IsNullOrEmpty(currentUserId))
                {
                    groupBookingsQuery = groupBookingsQuery.Where(c => c.Group.UserId == currentUserId);
                }

                var groupBookings = await groupBookingsQuery
                    .OrderBy(c => c.Date)
                    .ThenBy(c => c.StartMin)
                    .ToListAsync();

                // Convert calendar bookings to TemplateView format - all as primary (blue) bookings
                var templateViews = new List<TemplateView>();
                foreach (var cb in groupBookings)
                {
                    templateViews.Add(new TemplateView
                    {
                        Id = cb.Id,
                        ScheduleTemplateId = cb.SourceTemplateId ?? Guid.Empty,
                        AreaId = cb.AreaId,
                        GroupId = cb.GroupId,
                        DayOfWeek = GetDayOfWeekFromDate(cb.Date),
                        StartMin = cb.StartMin,
                        EndMin = cb.EndMin,
                        Notes = cb.Notes,
                        Group = cb.Group,
                        Area = cb.Area,
                        IsGhost = false, // All group filter bookings are primary (blue)
                        SourceAreaName = $"{cb.Area?.Place?.Name ?? "Okänd plats"} - {cb.Area?.Name ?? "Okänd yta"}",
                        Date = cb.Date,
                        Published = cb.Published,
                        PublishedAt = cb.PublishedAt
                    });
                }

                allTemplates = templateViews;
                weekBookings = groupBookings;
            }
            else
            {
                // Kalender: load calendar bookings for the current week
                var weekStart = UI.CurrentWeekStart;
                var weekEnd = UI.CurrentWeekEnd;

                if (UI.SelectedAreaId.HasValue && selectedArea != null)
                {
                    // PERF: Use cached area IDs from areaCache instead of querying DB again
                    var allPlaceAreaIds = areaCache.Values
                        .Where(a => a.PlaceId == selectedArea.PlaceId)
                        .Select(a => a.Id)
                        .ToList();
                    
                    // Pre-load leaf counts for all areas (in parallel with booking query)
                    var leafCountTask = LoadLeafCountCacheAsync(allPlaceAreaIds);

                    var overlappingBookingsQuery = db.CalendarBookings
                        .Where(c => c.Date >= weekStart && c.Date <= weekEnd && allPlaceAreaIds.Contains(c.AreaId))
                        .Include(c => c.Group)
                        .Include(c => c.Area)
                        .ThenInclude(a => a.Place)
                        .AsNoTracking();

                    if (!currentIsAdmin && !string.IsNullOrEmpty(currentUserId))
                    {
                        overlappingBookingsQuery = overlappingBookingsQuery.Where(c => c.Group.UserId == currentUserId);
                    }

                    // PERF: Run leaf count and booking query in parallel
                    var bookingTask = overlappingBookingsQuery
                        .OrderBy(c => c.Date)
                        .ThenBy(c => c.StartMin)
                        .ToListAsync();
                    await Task.WhenAll(leafCountTask, bookingTask);
                    var overlappingBookings = await bookingTask;

                    // Convert calendar bookings to TemplateView format with proper ghost logic
                    var templateViews = new List<TemplateView>();
                    foreach (var cb in overlappingBookings)
                    {
                        var isGhost = false;
                        if (cb.AreaId != selectedArea.Id)
                        {
                            // Check if this booking should show as ghost using hierarchy logic
                            isGhost = ShouldShowAsGhost(selectedArea, cb.Area);
                        }

                        templateViews.Add(new TemplateView
                        {
                            Id = cb.Id,
                            ScheduleTemplateId = cb.SourceTemplateId ?? Guid.Empty,
                            AreaId = cb.AreaId,
                            GroupId = cb.GroupId,
                            DayOfWeek = GetDayOfWeekFromDate(cb.Date),
                            StartMin = cb.StartMin,
                            EndMin = cb.EndMin,
                            Notes = cb.Notes,
                            Group = cb.Group,
                            Area = cb.Area,
                            IsGhost = isGhost,
                            SourceAreaName = $"{cb.Area?.Name ?? "Okänd yta"}",
                            Date = cb.Date,
                            Published = cb.Published,
                            PublishedAt = cb.PublishedAt
                        });
                    }

                    allTemplates = templateViews;
                    weekBookings = overlappingBookings.Where(cb => cb.AreaId == selectedArea.Id).ToList();
                }
                else if (UI.SelectedPlaceId.HasValue)
                {
                    var placeAreaIds = db.Areas
                        .Where(a => a.PlaceId == UI.SelectedPlaceId.Value)
                        .Select(a => a.Id)
                        .ToList();

                    var placeBookingsQuery = db.CalendarBookings
                        .Where(c => c.Date >= weekStart && c.Date <= weekEnd && placeAreaIds.Contains(c.AreaId))
                        .Include(c => c.Group)
                        .Include(c => c.Area)
                        .ThenInclude(a => a.Place)
                        .AsNoTracking();

                    if (!currentIsAdmin && !string.IsNullOrEmpty(currentUserId))
                    {
                        placeBookingsQuery = placeBookingsQuery.Where(c => c.Group.UserId == currentUserId);
                    }

                    var placeBookings = await placeBookingsQuery
                        .OrderBy(c => c.Date)
                        .ThenBy(c => c.StartMin)
                        .ToListAsync();

                    // Convert calendar bookings to TemplateView format
                    var templateViews = new List<TemplateView>();
                    foreach (var cb in placeBookings)
                    {
                        templateViews.Add(new TemplateView
                        {
                            Id = cb.Id,
                            ScheduleTemplateId = cb.SourceTemplateId ?? Guid.Empty,
                            AreaId = cb.AreaId,
                            GroupId = cb.GroupId,
                            DayOfWeek = GetDayOfWeekFromDate(cb.Date),
                            StartMin = cb.StartMin,
                            EndMin = cb.EndMin,
                            Notes = cb.Notes,
                            Group = cb.Group,
                            Area = cb.Area,
                            IsGhost = false,
                            SourceAreaName = $"{cb.Area?.Place?.Name ?? "Okänd plats"} - {cb.Area?.Name ?? "Okänd yta"}",
                            Date = cb.Date,
                            Published = cb.Published,
                            PublishedAt = cb.PublishedAt
                        });
                    }

                    allTemplates = templateViews;
                    weekBookings = placeBookings;
                }
                else
                {
                    // Kalendervyn utan vald area/plats: visa ALLA bokningar för veckan
                    // Detta är viktigt när man kopierar från mall eftersom mallen kan innehålla bokningar från olika areas
                    var allBookingsQuery = db.CalendarBookings
                        .Where(c => c.Date >= weekStart && c.Date <= weekEnd)
                        .Include(c => c.Group)
                        .Include(c => c.Area)
                        .ThenInclude(a => a.Place)
                        .AsNoTracking();

                    if (!currentIsAdmin && !string.IsNullOrEmpty(currentUserId))
                    {
                        allBookingsQuery = allBookingsQuery.Where(c => c.Group.UserId == currentUserId);
                    }

                    var allBookings = await allBookingsQuery
                        .OrderBy(c => c.Date)
                        .ThenBy(c => c.StartMin)
                        .ToListAsync();

                    // Convert calendar bookings to TemplateView format
                    var templateViews = new List<TemplateView>();
                    foreach (var cb in allBookings)
                    {
                        templateViews.Add(new TemplateView
                        {
                            Id = cb.Id,
                            ScheduleTemplateId = cb.SourceTemplateId ?? Guid.Empty,
                            AreaId = cb.AreaId,
                            GroupId = cb.GroupId,
                            DayOfWeek = GetDayOfWeekFromDate(cb.Date),
                            StartMin = cb.StartMin,
                            EndMin = cb.EndMin,
                            Notes = cb.Notes,
                            Group = cb.Group,
                            Area = cb.Area,
                            IsGhost = false,
                            SourceAreaName = $"{cb.Area?.Place?.Name ?? "Okänd plats"} - {cb.Area?.Name ?? "Okänd yta"}",
                            Date = cb.Date,
                            Published = cb.Published,
                            PublishedAt = cb.PublishedAt
                        });
                    }

                    allTemplates = templateViews;
                    weekBookings = allBookings;
                }
            }


            // Post-process group filter to ensure place/area format
        if (!UI.IsCalendarViewMode && UI.IsGroupFilterActive && UI.FilteredGroupId.HasValue)
        {
            foreach (var template in allTemplates)
            {
                template.IsGhost = false;
                if (template.Area != null && template.Area.Place == null && areaCache.TryGetValue(template.AreaId, out var cachedArea))
                {
                    template.Area = cachedArea;
                }

                if (template.Area?.Place != null)
                {
                    template.SourceAreaName = $"{template.Area.Place.Name} - {template.Area.Name}";
                }
                else if (!string.IsNullOrWhiteSpace(template.SourceAreaName))
                {
                    // Keep existing
                }
                else if (template.Area != null)
                {
                    template.SourceAreaName = template.Area.Name ?? "Okänd yta";
                }
                else
                {
                    template.SourceAreaName = "Okänd plats";
                }
            }

            weekBookings = new List<CalendarBooking>();
        }


            var userId = await UserContext.GetCurrentUserIdAsync();
            var isAdmin = await UserContext.IsAdminAsync();
            var groupQuery = db.Groups.AsQueryable();
            if (!isAdmin && !string.IsNullOrEmpty(userId))
            {
                groupQuery = groupQuery.Where(g => g.UserId == userId);
            }
            groups = await groupQuery.OrderBy(g => g.Name).ToListAsync();
            // #region agent log
            LogDebug("WeekGrid.razor:1319", "LoadDataAsync exit (success)", new { allTemplatesCount = allTemplates?.Count ?? 0, weekBookingsCount = weekBookings?.Count ?? 0, isCalendarViewMode = UI.IsCalendarViewMode, selectedAreaId = UI.SelectedAreaId?.ToString(), selectedTemplateId = UI.SelectedTemplateId?.ToString() }, "D");
            // #endregion
            StateHasChanged();
        }
        catch (Exception ex)
        {
            // #region agent log
            LogDebug("WeekGrid.razor:1323", "LoadDataAsync error", new { error = ex.Message }, "D");
            // #endregion
            Console.WriteLine($"Error loading data: {ex.Message}");
            allTemplates = new List<TemplateView>();
            weekBookings = new List<CalendarBooking>();
        }
    }

    private List<TemplateView> GetTemplatesForDay(int dayOfWeek)
    {
        var templates = allTemplates.Where(t => t.DayOfWeek == dayOfWeek).ToList();
        
        // CRITICAL FIX: When group filtering is active, templates are already filtered in LoadDataAsync
        // Don't filter again here - it causes no bookings to show
        if (UI.IsGroupFilterActive)
        {
            // Templates are already filtered by group in LoadDataAsync - just return them
            return templates;
        }
        
        // If a specific area is selected, only show templates for that area (not ghosts)
        if (UI.SelectedAreaId.HasValue)
        {
            return templates.Where(t => t.AreaId == UI.SelectedAreaId.Value && !t.IsGhost).ToList();
        }
        
        // If no area selected, show all non-ghost templates
        return templates.Where(t => !t.IsGhost).ToList();
    }

    private List<TemplateView> GetGhostsForDay(int dayOfWeek)
    {
        var ghosts = allTemplates.Where(t => t.DayOfWeek == dayOfWeek && t.IsGhost).ToList();
        
        // If group filtering is active, don't show any ghosts (all bookings are primary)
        if (UI.IsGroupFilterActive)
        {
            return new List<TemplateView>();
        }
        
        // If a specific area is selected, only show ghosts that are relevant to that area
        if (UI.SelectedAreaId.HasValue)
        {
            return ghosts.Where(t => t.AreaId != UI.SelectedAreaId.Value).ToList();
        }
        
        return ghosts;
    }
    
    private List<PositionedBooking> GetPositionedBookingsForDay(int dayOfWeek)
    {
        // Get all bookings (templates and ghosts) for this day
        var templates = GetTemplatesForDay(dayOfWeek);
        var ghosts = GetGhostsForDay(dayOfWeek);
        var allBookings = templates.Concat(ghosts).ToList();
        
        if (UI.IsGroupFilterActive && UI.FilteredGroupId.HasValue)
        {
            allBookings = allBookings
                .Where(t => t.GroupId == UI.FilteredGroupId.Value)
                .ToList();
        }
        
        return CalculatePositions(allBookings);
    }
    
    private List<PositionedBooking> GetPositionedCalendarForDay(DateOnly date)
    {
        // Get all bookings for this day from allTemplates (which contains calendar bookings as TemplateView in calendar mode)
        var allBookings = allTemplates.Where(t => t.Date.HasValue && t.Date.Value == date).ToList();
        
        if (UI.IsGroupFilterActive && UI.FilteredGroupId.HasValue)
        {
            allBookings = allBookings
                .Where(t => t.GroupId == UI.FilteredGroupId.Value)
                .ToList();
        }
        
        return CalculatePositions(allBookings);
    }
    
    private List<CalendarBooking> GetCalendarForDay(DateOnly date)
    {
        return weekBookings.Where(b => b.Date == date).ToList();
    }
    
    private string GetPositionStyle(double widthPercent, double leftPercent)
    {
        if (widthPercent >= 99.9) // Full width - use left/right for padding
        {
            return "left: 2px; right: 2px;";
        }
        else
        {
            // Force invariant culture to ensure CSS uses dot decimal separator
            var leftCss = leftPercent.ToString("0.##", System.Globalization.CultureInfo.InvariantCulture);
            var widthCss = widthPercent.ToString("0.##", System.Globalization.CultureInfo.InvariantCulture);
            return $"left: {leftCss}%; width: {widthCss}%;";
        }
    }

    private int GetDayOfWeekFromDate(DateOnly date)
    {
        // Convert DateOnly to Monday-based day of week (1 = Monday, 7 = Sunday)
        var dayOfWeek = (int)date.DayOfWeek;
        return dayOfWeek == 0 ? 7 : dayOfWeek;
    }

    private async Task LoadLeafCountCacheAsync(List<Guid> areaIds)
    {
        await using var db = await DbFactory.CreateDbContextAsync();
        // Load leaf counts for all areas at once
        var leafCounts = await db.AreaLeafs
            .Where(al => areaIds.Contains(al.AreaId))
            .GroupBy(al => al.AreaId)
            .Select(g => new { AreaId = g.Key, Count = g.Count() })
            .ToListAsync();
            
        areaLeafCountCache.Clear();
        foreach (var lc in leafCounts)
        {
            areaLeafCountCache[lc.AreaId] = lc.Count;
        }

        // Load sort order for each area based on the earliest leaf (min SortOrder)
        var areaOrders = await db.AreaLeafs
            .Where(al => areaIds.Contains(al.AreaId))
            .Join(db.Leafs, al => al.LeafId, l => l.Id, (al, l) => new { al.AreaId, l.SortOrder })
            .GroupBy(x => x.AreaId)
            .Select(g => new { AreaId = g.Key, SortOrder = g.Min(x => x.SortOrder) })
            .ToListAsync();

        areaSortOrderCache.Clear();
        foreach (var ao in areaOrders)
        {
            areaSortOrderCache[ao.AreaId] = ao.SortOrder;
        }
        
        // Set selected area total leafs
        if (UI.SelectedAreaId.HasValue && areaLeafCountCache.ContainsKey(UI.SelectedAreaId.Value))
        {
            selectedAreaTotalLeafs = areaLeafCountCache[UI.SelectedAreaId.Value];
        }
        else
        {
            selectedAreaTotalLeafs = 1; // Fallback
        }
    }
    
    private int GetCachedLeafCount(Guid areaId)
    {
        return areaLeafCountCache.TryGetValue(areaId, out var count) ? count : 1;
    }
    
    private List<PositionedBooking> CalculatePositions(List<TemplateView> bookings)
    {
        var result = new List<PositionedBooking>();
        
        if (bookings.Count == 0)
        {
            return result;
        }
        
        if (UI.IsGroupFilterActive)
        {
            return CalculatePositionsForGroupFilter(bookings);
        }
        
        if (!UI.SelectedAreaId.HasValue || selectedArea == null)
            return result;
        
        if (selectedAreaTotalLeafs == 0) selectedAreaTotalLeafs = 1;
        
        // Prepare tuples for grouping
        var bookingsWithMeta = new List<(TemplateView booking, int start, int end, int leafCount, double widthPct)>();
        foreach (var b in bookings)
        {
            var leafCount = GetCachedLeafCount(b.AreaId);
            var widthPct = GetWidthPercentFor(b, leafCount);
            bookingsWithMeta.Add((b, b.StartMin, b.EndMin, leafCount, widthPct));
        }
        
        // Group overlapping bookings by time
        var groups = new List<List<(TemplateView booking, int start, int end, int leafCount, double widthPct)>>();
        var sortedBookings = bookingsWithMeta.OrderBy(b => b.start).ThenBy(b => b.end).ToList();
        
        foreach (var booking in sortedBookings)
        {
            bool addedToGroup = false;
            foreach (var group in groups)
            {
                // Check if this booking overlaps with any in the group
                if (group.Any(g => !(booking.end <= g.start || booking.start >= g.end)))
                {
                    group.Add(booking);
                    addedToGroup = true;
                    break;
                }
            }
            
            if (!addedToGroup)
            {
                groups.Add(new List<(TemplateView, int, int, int, double)> { booking });
            }
        }
        
        // Calculate positions for each group
        foreach (var group in groups)
        {
            if (group.Count == 1)
            {
                // Single booking - full width based on its leaf count
                var b = group[0];
                var widthPercent = Math.Min(100.0, b.widthPct);
                result.Add(new PositionedBooking
                {
                    Booking = b.booking,
                    IsGhost = b.booking.IsGhost,
                    WidthPercent = widthPercent,
                    LeftPercent = 0,
                    LeafCount = b.leafCount
                });
            }
            else
            {
                // Multiple overlapping bookings - arrange side by side
                // Sort by configured place order (leaf SortOrder), then width, then GUID for stability
                var sortedGroup = group
                    .OrderBy(b => GetAreaSortOrder(b.booking.AreaId))
                    .ThenByDescending(b => b.widthPct)
                    .ThenBy(b => b.booking.AreaId)
                    .ToList();
                
                double currentLeft = 0;
                foreach (var b in sortedGroup)
                {
                    var widthPercent = Math.Min(100.0, b.widthPct);
                    result.Add(new PositionedBooking
                    {
                        Booking = b.booking,
                        IsGhost = b.booking.IsGhost,
                        WidthPercent = widthPercent,
                        LeftPercent = currentLeft,
                        LeafCount = b.leafCount
                    });
                    currentLeft += widthPercent;
                }
            }
        }
        
        return result;
    }

    private List<PositionedBooking> CalculatePositionsForGroupFilter(List<TemplateView> bookings)
    {
        var result = new List<PositionedBooking>();
        if (bookings.Count == 0)
        {
            return result;
        }
        
        static bool Overlaps(TemplateView a, TemplateView b) =>
            !(a.EndMin <= b.StartMin || a.StartMin >= b.EndMin);
        
        var sorted = bookings.OrderBy(b => b.StartMin).ThenBy(b => b.EndMin).ToList();
        var groups = new List<List<TemplateView>>();
        
        foreach (var booking in sorted)
        {
            var group = groups.FirstOrDefault(g => g.Any(existing => Overlaps(existing, booking)));
            if (group is null)
            {
                group = new List<TemplateView>();
                groups.Add(group);
            }
            group.Add(booking);
        }
        
        foreach (var group in groups)
        {
            var ordered = group.OrderBy(b => b.StartMin).ThenBy(b => b.EndMin).ToList();
            var count = Math.Max(1, ordered.Count);
            var width = 100.0 / count;
            
            for (var i = 0; i < ordered.Count; i++)
            {
                var booking = ordered[i];
                var left = i * width;
                
                booking.WidthPercent = width;
                booking.LeftPercent = left;
                
                result.Add(new PositionedBooking
                {
                    Booking = booking,
                    IsGhost = false,
                    WidthPercent = width,
                    LeftPercent = left,
                    LeafCount = 1
                });
            }
        }
        
        return result;
    }

    private int GetAreaSortOrder(Guid areaId)
    {
        if (areaSortOrderCache.TryGetValue(areaId, out var sort)) return sort;
        // Fallback: try to infer from area name path to get a stable order
        if (areaCache.TryGetValue(areaId, out var area))
        {
            if (area != null && !string.IsNullOrEmpty(area.Path))
            {
                // Use lexical order of Path as a stable fallback
                return area.Path.GetHashCode(StringComparison.OrdinalIgnoreCase);
            }
        }
        return int.MaxValue;
    }

    private double GetWidthPercentFor(TemplateView booking, int bookingLeafCount)
    {
        // Prefer hierarchical width rules if relationship is ancestor/descendant; fallback to leaf ratio otherwise
        try
        {
            var bookingArea = booking.Area ?? (areaCache.TryGetValue(booking.AreaId, out var ba) ? ba : null);
            if (bookingArea == null || selectedArea == null)
            {
                var total = Math.Max(1, GetCachedLeafCount(selectedArea?.Id ?? Guid.Empty));
                return Math.Min(100.0, (double)bookingLeafCount / total * 100.0);
            }

            if (selectedArea.Id == bookingArea.Id)
            {
                return 100.0;
            }

            // If viewing ancestor of booking area
            if (IsAncestorOf(selectedArea, bookingArea))
            {
                // Always compute proportionally by leaf coverage relative to the selected area
                var total = Math.Max(1, GetCachedLeafCount(selectedArea.Id));
                return Math.Min(100.0, (double)bookingLeafCount / total * 100.0);
            }

            // If viewing descendant of booking area (parent/ancestor booked): occupy full width
            if (IsAncestorOf(bookingArea, selectedArea))
            {
                return 100.0;
            }

            // Siblings/unrelated should normally be filtered out; fallback to leaf ratio
            var fallbackTotal = Math.Max(1, GetCachedLeafCount(selectedArea.Id));
            return Math.Min(100.0, (double)bookingLeafCount / fallbackTotal * 100.0);
        }
        catch
        {
            var safeTotal = Math.Max(1, GetCachedLeafCount(selectedArea?.Id ?? Guid.Empty));
            return Math.Min(100.0, (double)bookingLeafCount / safeTotal * 100.0);
        }
    }

    private int GetAncestorDistance(Area ancestor, Area descendant)
    {
        var distance = 0;
        var current = descendant;
        while (current.ParentAreaId != null)
        {
            if (current.ParentAreaId == ancestor.Id)
            {
                return distance + 1;
            }
            current = current.ParentAreaId.HasValue && areaCache.TryGetValue(current.ParentAreaId.Value, out var parent) ? parent : null;
            if (current == null) break;
            distance++;
        }
        return int.MaxValue; // Not an ancestor
    }

    private bool IsAncestorOf(Area potentialAncestor, Area potentialDescendant)
    {
        // Check if potentialAncestor is an ancestor of potentialDescendant
        var current = potentialDescendant;
        while (current.ParentAreaId != null)
        {
            if (current.ParentAreaId == potentialAncestor.Id)
                return true;
            current = current.ParentAreaId.HasValue && areaCache.TryGetValue(current.ParentAreaId.Value, out var parent) ? parent : null;
            if (current == null) break;
        }
        return false;
    }
    
    private bool IsChildOf(Area parent, Area potentialChild)
    {
        return potentialChild.ParentAreaId == parent.Id;
    }
    
    private bool IsGrandchildOf(Area potentialGrandparent, Area potentialGrandchild)
    {
        if (potentialGrandchild.ParentAreaId == null) return false;
        var parent = potentialGrandchild.ParentAreaId.HasValue && areaCache.TryGetValue(potentialGrandchild.ParentAreaId.Value, out var p) ? p : null;
        return parent != null && parent.ParentAreaId == potentialGrandparent.Id;
    }
    
    private bool IsSiblingOf(Area area1, Area area2)
    {
        return area1.ParentAreaId != null && area1.ParentAreaId == area2.ParentAreaId;
    }
    
    private bool ShouldShowAsGhost(Area selectedArea, Area sourceArea)
    {
        // Ghost blocks should only appear for parent-child relationships
        // Siblings (same level) should NOT show as ghosts
        
        if (selectedArea == null || sourceArea == null)
        {
            Console.WriteLine($"DEBUG: ShouldShowAsGhost - selectedArea: {selectedArea?.Name ?? "NULL"}, sourceArea: {sourceArea?.Name ?? "NULL"}");
            return false;
        }
        
        if (selectedArea.Id == sourceArea.Id)
            return false; // Same area
            
        // Check if sourceArea is a child or descendant of selectedArea
        if (IsAncestorOf(selectedArea, sourceArea))
        {
            Console.WriteLine($"DEBUG: ShouldShowAsGhost - {sourceArea.Name} is child of {selectedArea.Name} -> TRUE");
            return true;
        }
            
        // Check if selectedArea is a child or descendant of sourceArea
        if (IsAncestorOf(sourceArea, selectedArea))
        {
            Console.WriteLine($"DEBUG: ShouldShowAsGhost - {selectedArea.Name} is child of {sourceArea.Name} -> TRUE");
            return true;
        }
            
        // Siblings should not show as ghosts
        Console.WriteLine($"DEBUG: ShouldShowAsGhost - {selectedArea.Name} and {sourceArea.Name} are siblings or unrelated -> FALSE");
        return false;
    }

    private string GetDayName(int dayOfWeek)
    {
        return dayOfWeek switch
        {
            1 => "Mån",
            2 => "Tis", 
            3 => "Ons",
            4 => "Tor",
            5 => "Fre",
            6 => "Lör",
            7 => "Sön",
            _ => ""
        };
    }
    
    private string GetFullDayName(int dayOfWeek)
    {
        return dayOfWeek switch
        {
            1 => "Måndag",
            2 => "Tisdag", 
            3 => "Onsdag",
            4 => "Torsdag",
            5 => "Fredag",
            6 => "Lördag",
            7 => "Söndag",
            _ => ""
        };
    }

    private string FormatDayHeader(DateOnly date)
    {
        var culture = new System.Globalization.CultureInfo("sv-SE");
        return date.ToDateTime(TimeOnly.MinValue).ToString("dd MMM", culture).ToLowerInvariant().Replace(".", "");
    }
    
    private bool IsToday(DateOnly date)
    {
        var today = DateOnly.FromDateTime(DateTime.Today);
        return date == today;
    }

    private int GetCurrentDayIndex()
    {
        var day = (int)UI.CurrentWeekStart.DayOfWeek;
        return day == 0 ? 7 : day;
    }

    private string FormatTime(int minutes)
    {
        var hours = minutes / 60;
        var mins = minutes % 60;
        return $"{hours:00}:{mins:00}";
    }
    
    private string GetBookingColorStyle(TemplateView template, bool isGhost)
    {
        // Ghost bookings ALWAYS use gray colors for better contrast
        if (isGhost)
        {
            return "background-color: #f3f4f6; border: 1px dashed #d1d5db; color: #6b7280;";
        }
        
        if (template.Group == null)
        {
            // Default colors if no group
            var defaultColor = SchedulerMVP.Data.Entities.GroupDisplayColors.Colors["Ljusblå"];
            return $"background-color: {defaultColor.Background}; border: 1px solid {defaultColor.Border}; color: {defaultColor.Text};";
        }
        
        // Get color from group's DisplayColor, default to Ljusblå if not found
        var displayColor = template.Group.DisplayColor ?? "Ljusblå";
        var colorInfo = SchedulerMVP.Data.Entities.GroupDisplayColors.Colors.GetValueOrDefault(
            displayColor, 
            SchedulerMVP.Data.Entities.GroupDisplayColors.Colors["Ljusblå"]);
        
        return $"background-color: {colorInfo.Background}; border: 1px solid {colorInfo.Border}; color: {colorInfo.Text};";
    }
    
    private string HexToRgba(string hex, double alpha)
    {
        // Simple hex to rgba conversion for ghost effect
        // Remove # if present
        hex = hex.TrimStart('#');
        
        if (hex.Length == 6)
        {
            var r = Convert.ToInt32(hex.Substring(0, 2), 16);
            var g = Convert.ToInt32(hex.Substring(2, 2), 16);
            var b = Convert.ToInt32(hex.Substring(4, 2), 16);
            return $"rgba({r}, {g}, {b}, {alpha.ToString(System.Globalization.CultureInfo.InvariantCulture)})";
        }
        
        return hex; // Fallback to original hex if conversion fails
    }
    




    private async Task OnTemplateClick(TemplateView template, MouseEventArgs e)
    {
        // Check if a resize operation just finished - if so, don't open popover
        try
        {
            var justFinishedResize = await JSRuntime.InvokeAsync<bool>("SchedulerMVP.checkJustFinishedResize");
            if (justFinishedResize)
            {
                return; // Don't open popover if resize just finished
            }
        }
        catch
        {
            // If JavaScript call fails, continue normally (allow popover to open)
        }
        
        // Open popover for template in Veckoschema mode
        popoverTemplate = template;
        popoverX = e.ClientX;
        popoverY = e.ClientY;
        popoverOpen = true;
        StateHasChanged();
    }

    private async Task OnDayContentClick(MouseEventArgs e, int dayIndex)
    {
        // Only allow clicking if we have a context for new booking
        if (!UI.SelectedAreaId.HasValue && !UI.IsGroupFilterActive)
        {
            return;
        }

        // Calculate the clicked time based on mouse position
        // Each hour is 60px tall, so offsetY / 60 gives us the hour
        var offsetY = e.OffsetY;
        var totalMinutes = (int)offsetY; // Since 1 minute = 1px
        
        // Round to nearest 15-minute interval
        var roundedMinutes = (int)(Math.Round(totalMinutes / 15.0) * 15);
        
        // Calculate hour and minute
        var hour = roundedMinutes / 60;
        var minute = roundedMinutes % 60;
        
        // Clamp to valid ranges
        if (hour < 0) hour = 0;
        if (hour >= 24) hour = 23;
        if (minute < 0) minute = 0;
        if (minute >= 60) minute = 45;
        
        // Format the start time
        var startTime = $"{hour:00}:{minute:00}";
        
        // Invoke the OnOpenModal callback to trigger the modal in Index.razor
        // In calendar mode, dayIndex still represents the day of week (1-7), and BookingModal
        // will calculate the actual date from UI.CurrentWeekStart + dayIndex
        await OnOpenModal.InvokeAsync((dayIndex, startTime));
    }

    private void OnDayContentMouseMove(MouseEventArgs e, int dayIndex)
    {
        // Only show tooltip when an area is selected
        if (!UI.SelectedAreaId.HasValue)
        {
            _tooltipText = "";
            return;
        }

        _tooltipDay = dayIndex;
        _tooltipMouseY = e.OffsetY;
        
        // Calculate the time based on mouse position
        var totalMinutes = (int)_tooltipMouseY;
        var roundedMinutes = (int)(Math.Round(totalMinutes / 15.0) * 15);
        var hour = roundedMinutes / 60;
        var minute = roundedMinutes % 60;
        
        // Clamp to valid ranges
        if (hour < 0) hour = 0;
        if (hour >= 24) hour = 23;
        if (minute < 0) minute = 0;
        if (minute >= 60) minute = 45;
        
        var dayName = GetDayName(dayIndex);
        _tooltipText = $"Lägg till bokning {dayName} {hour:00}:{minute:00}";
    }

    private void OnDayContentMouseLeave()
    {
        _tooltipDay = null;
        _tooltipText = "";
    }

    private string GetTooltipText(int dayIndex)
    {
        // Return the current tooltip text if it's for this day
        if (_tooltipDay == dayIndex && !string.IsNullOrEmpty(_tooltipText))
        {
            return _tooltipText;
        }
        return "";
    }

    private void PreviousWeek()
    {
        UI.CurrentWeekStart = UI.CurrentWeekStart.AddDays(-7);
    }

    private void NextWeek()
    {
        UI.CurrentWeekStart = UI.CurrentWeekStart.AddDays(7);
    }

    // Template management
    private List<SchedulerMVP.Data.Entities.ScheduleTemplate> templates = new();
    private bool menuOpen;
    
    // Note: Calendar navigation fields moved to TopBar.razor


    private async Task LoadTemplates()
    {
        templates = await TemplateService.GetTemplatesAsync();
        if (UI.SelectedTemplateId is Guid tid)
        {
            if (!templates.Any(t => t.Id == tid))
            {
                UI.SelectedTemplateId = templates.FirstOrDefault()?.Id;
            }
        }
        else
        {
            UI.SelectedTemplateId = templates.FirstOrDefault()?.Id;
        }
        StateHasChanged();
    }

    private Task OnTemplateChanged(ChangeEventArgs e)
    {
        if (Guid.TryParse(e.Value?.ToString(), out var id))
        {
            UI.SelectedTemplateId = id;
            UI.RaiseChanged();
        }
        return Task.CompletedTask;
    }

    private void ToggleMenu() => menuOpen = !menuOpen;
    private void OpenEdit() { menuOpen = false; }
    private void Save() { menuOpen = false; }
    private void OpenCreate() { menuOpen = false; }
    private void OpenCopy() { menuOpen = false; }
    private void OpenDelete() { menuOpen = false; }
    
    // Note: Calendar navigation methods moved to TopBar.razor

    private async Task RefreshAfterEdit()
    {
        await LoadDataAsync();
    }

    [Parameter] public EventCallback<(int dayOfWeek, string startTime)> OnOpenModal { get; set; }
    [Parameter] public EventCallback<Guid> OnOpenCalendarBookingEdit { get; set; }
    [Parameter] public EventCallback<Guid> OnOpenTemplateEdit { get; set; }
    

    [JSInvokable]
    public async Task HandleBookingDrop(DropData data)
    {
        try
        {
            if (!Guid.TryParse(data.BookingId, out var bookingId))
            {
                Console.WriteLine($"Invalid booking ID: {data.BookingId}");
                return;
            }

            if (data.BookingType == "calendar")
            {
                // Update calendar booking
                await using var db = await DbFactory.CreateDbContextAsync();
                var booking = await db.CalendarBookings
                    .Include(b => b.Group)
                    .Include(b => b.Area)
                    .FirstOrDefaultAsync(b => b.Id == bookingId);

                if (booking == null)
                {
                    Console.WriteLine($"Calendar booking not found: {bookingId}");
                    return;
                }

                // Calculate new date for calendar booking
                // newDay is day index (1-7) for week view, or date string for calendar view
                DateOnly newDate;
                if (UI.IsCalendarViewMode)
                {
                    // For calendar view, calculate date from week start + day index
                    newDate = UI.CurrentWeekStart.AddDays(data.NewDay - 1);
                }
                else
                {
                    // For template view, convert day of week to date
                    newDate = UI.CurrentWeekStart.AddDays(data.NewDay - 1);
                }

                // Update booking
                booking.Date = newDate;
                booking.StartMin = data.NewStartMin;
                booking.EndMin = data.NewEndMin;
                booking.UpdatedAt = DateTime.UtcNow;

                await db.SaveChangesAsync();

                // Force refresh
                UI.ForceRefresh = true;
                UI.RaiseChanged();
                await LoadDataAsync();
                await InvokeAsync(StateHasChanged);
            }
            else if (data.BookingType == "template")
            {
                // Update booking template
                await using var db = await DbFactory.CreateDbContextAsync();
                var template = await db.BookingTemplates
                    .Include(bt => bt.ScheduleTemplate)
                    .FirstOrDefaultAsync(bt => bt.Id == bookingId);

                if (template == null)
                {
                    Console.WriteLine($"Template booking not found: {bookingId}");
                    return;
                }

                // Update template (only day, start, end - not area/group)
                template.DayOfWeek = data.NewDay;
                template.StartMin = data.NewStartMin;
                template.EndMin = data.NewEndMin;
                template.UpdatedAt = DateTime.UtcNow;

                await db.SaveChangesAsync();

                // Force refresh
                UI.ForceRefresh = true;
                UI.RaiseChanged();
                await LoadDataAsync();
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error handling booking drop: {ex.Message}");
            Console.WriteLine($"Stack trace: {ex.StackTrace}");
        }
    }

    // CheckBookingConflict method moved to WeekGrid.razor.cs


    public class ConflictCheckData
    {
        public string BookingId { get; set; } = string.Empty;
        public string BookingType { get; set; } = string.Empty; // "template" or "calendar"
        public int NewDay { get; set; }
        public int NewStartMin { get; set; }
        public int NewEndMin { get; set; }
        // For calendar bookings: the date as string (yyyy-MM-dd) or null
        public string? Date { get; set; }
    }

    public class DropData
    {
        public string BookingId { get; set; } = string.Empty;
        public string BookingType { get; set; } = string.Empty; // "template" or "calendar"
        public int NewDay { get; set; }
        public int NewStartMin { get; set; }
        public int NewEndMin { get; set; }
    }

    public void Dispose()
    {
        UI.OnChanged -= StateHasChanged;
        if (_dotNetRef != null)
        {
            try
            {
                _dotNetRef.Dispose();
            }
            catch
            {
                // Ignore disposal errors - reference might already be disposed
            }
            _dotNetRef = null;
        }
        // Clean up semaphore
        try
        {
            _loadDataLock?.Dispose();
        }
        catch
        {
            // Ignore disposal errors
        }
    }
    
    private bool popoverOpen = false;
    private CalendarBooking? popoverBooking = null;
    private TemplateView? popoverTemplate = null;
    private double popoverX = 0;
    private double popoverY = 0;
    
    private async Task OnCalendarBookingClick(CalendarBooking booking, MouseEventArgs e)
    {
        // Check if a resize operation just finished - if so, don't open popover
        try
        {
            var justFinishedResize = await JSRuntime.InvokeAsync<bool>("SchedulerMVP.checkJustFinishedResize");
            if (justFinishedResize)
            {
                return; // Don't open popover if resize just finished
            }
        }
        catch
        {
            // If JavaScript call fails, continue normally (allow popover to open)
        }
        
        popoverBooking = booking;
        popoverX = e.ClientX;
        popoverY = e.ClientY;
        popoverOpen = true;
        StateHasChanged();
    }
    
    [JSInvokable]
    public async Task OnCalendarBookingClickFromJS(string bookingId, double clientX, double clientY)
    {
        if (Guid.TryParse(bookingId, out var id))
        {
            var booking = weekBookings.FirstOrDefault(b => b.Id == id);
            if (booking != null)
            {
                await OnCalendarBookingClick(booking, new MouseEventArgs { ClientX = clientX, ClientY = clientY });
            }
        }
    }
    
    [JSInvokable]
    public async Task OnTemplateClickFromJS(string templateId, double clientX, double clientY)
    {
        if (Guid.TryParse(templateId, out var id))
        {
            var template = allTemplates.FirstOrDefault(t => t.Id == id);
            if (template != null)
            {
                await OnTemplateClick(template, new MouseEventArgs { ClientX = clientX, ClientY = clientY });
            }
        }
    }
    
    private void ClosePopover()
    {
        popoverOpen = false;
        popoverBooking = null;
        popoverTemplate = null;
        StateHasChanged();
    }
    
    private async Task EditFromPopover()
    {
        if (popoverBooking != null)
        {
            var bookingId = popoverBooking.Id;
            ClosePopover();
            await OnOpenCalendarBookingEdit.InvokeAsync(bookingId);
        }
        else if (popoverTemplate != null)
        {
            var templateId = popoverTemplate.Id;
            ClosePopover();
            await OnOpenTemplateEdit.InvokeAsync(templateId);
        }
    }
    
    private async Task DeleteFromPopover()
    {
        if (popoverBooking != null)
        {
            try
            {
                await using var db = await DbFactory.CreateDbContextAsync();
                var booking = await db.CalendarBookings.FindAsync(popoverBooking.Id);
                if (booking != null)
                {
                    db.CalendarBookings.Remove(booking);
                    await db.SaveChangesAsync();
                    ClosePopover();
                    
                    // Force refresh to update counts in sidebar
                    UI.ForceRefresh = true;
                    UI.RaiseChanged();
                    await LoadDataAsync();
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error deleting calendar booking: {ex.Message}");
            }
        }
        else if (popoverTemplate != null)
        {
            try
            {
                await using var db = await DbFactory.CreateDbContextAsync();
                var template = await db.BookingTemplates.FindAsync(popoverTemplate.Id);
                if (template != null)
                {
                    db.BookingTemplates.Remove(template);
                    await db.SaveChangesAsync();
                    ClosePopover();
                    
                    // Force refresh to update counts in sidebar
                    UI.ForceRefresh = true;
                    UI.RaiseChanged();
                    await LoadDataAsync();
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error deleting template: {ex.Message}");
            }
        }
    }

    private string GetPlaceAreaLabel(TemplateView template)
    {
        string? placeName = template.Area?.Place?.Name;
        string? areaName = template.Area?.Name;

        if ((string.IsNullOrWhiteSpace(placeName) || string.IsNullOrWhiteSpace(areaName)) && template.AreaId != Guid.Empty)
        {
            if (areaCache.TryGetValue(template.AreaId, out var cachedArea))
            {
                placeName ??= cachedArea.Place?.Name;
                areaName ??= cachedArea.Name;
            }
        }

        if (string.IsNullOrWhiteSpace(placeName) || string.IsNullOrWhiteSpace(areaName))
        {
            var bookingMatch = weekBookings.FirstOrDefault(b => b.Id == template.Id);
            if (bookingMatch?.Area != null)
            {
                placeName ??= bookingMatch.Area.Place?.Name;
                areaName ??= bookingMatch.Area.Name;
            }
        }

        if ((string.IsNullOrWhiteSpace(placeName) || string.IsNullOrWhiteSpace(areaName)) && !string.IsNullOrWhiteSpace(template.SourceAreaName))
        {
            if (template.SourceAreaName.Contains(" - ", System.StringComparison.Ordinal))
            {
                return template.SourceAreaName;
            }
            areaName ??= template.SourceAreaName;
        }

        placeName = string.IsNullOrWhiteSpace(placeName) ? "Okänd plats" : placeName;
        areaName = string.IsNullOrWhiteSpace(areaName) ? "Okänd yta" : areaName;

        return $"{placeName} - {areaName}";
    }
}

<style>
    /* Visual feedback for clickable areas */
    .day-content {
        cursor: pointer;
        transition: background-color 0.1s ease;
    }
    
    .day-content:hover {
        background-color: rgba(59, 130, 246, 0.05);
    }
    
    .booking-block {
        cursor: pointer;
        transition: opacity 0.1s ease, transform 0.1s ease;
    }
    
    .booking-block:hover {
        opacity: 0.9;
        transform: translateY(-1px);
    }
    
    .booking-block:active {
        transform: translateY(0);
        opacity: 0.8;
    }
    
    /* Published check icon - positioned in top right corner */
    .published-check-icon {
        position: absolute;
        top: 2px;
        right: 2px;
        font-size: 16px;
        color: #16a34a;
        z-index: 15;
        pointer-events: none;
    }
    
    /* Published check icon for ghost bookings - gray scale */
    .published-check-icon-ghost {
        position: absolute;
        top: 2px;
        right: 2px;
        font-size: 16px;
        color: #6b7280;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 50%;
        padding: 1px;
        z-index: 10;
        pointer-events: none;
    }
</style>