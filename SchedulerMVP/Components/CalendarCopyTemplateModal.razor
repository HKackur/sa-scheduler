@inject SchedulerMVP.Services.IScheduleTemplateService TemplateService
@inject SchedulerMVP.Services.ICalendarBookingService CalendarBookingService
@inject SchedulerMVP.Services.UIState UI

@if (IsOpen)
{
    <div class="modal-container" @onclick="OnBackdrop">
        <div class="bm-modal" @onclick:stopPropagation="true">
            <div class="bm-header">
                <h3 class="bm-title">Lägg till från mall</h3>
            </div>
            <div class="bm-field">
                <label class="bm-label">Välj mall</label>
                <select class="bm-input" @onchange="OnTemplateChanged">
                    <option value="">-- Välj mall --</option>
                    @foreach (var template in templates)
                    {
                        <option value="@template.Id" selected="@(selectedTemplateId == template.Id)">@template.Name</option>
                    }
                </select>
            </div>
            <div class="bm-field">
                <label class="bm-label">Datumspann</label>
                <div style="display:flex;gap:8px;align-items:center">
                    <input type="date" class="bm-input" style="flex:1" value="@startDateString" @onchange="OnStartDateChanged" />
                    <span style="color:#6b7280">till</span>
                    <input type="date" class="bm-input" style="flex:1" value="@endDateString" @onchange="OnEndDateChanged" />
                </div>
                @if (endDate < startDate)
                {
                    <div style="margin-top:6px;color:#dc2626;font-size:12px">Slutdatum måste vara samma eller efter startdatum.</div>
                }
            </div>
            <div class="bm-actions">
                <button type="button" @onclick="OnCancel" class="btn-outline">Avbryt</button>
                <button type="button" @onclick="OnCopy" class="btn-primary" disabled="@(!selectedTemplateId.HasValue || endDate < startDate)">Lägg till schema</button>
            </div>
        </div>
    </div>
    <style>
        /* Match ScheduleTemplateEditModal exact structure and styling */
        .modal-container{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.45);z-index:4000;display:flex;justify-content:center;align-items:flex-start;padding-top:50px;overflow-y:auto}
        .bm-modal{background:#fff;color:#0f1720;padding:28px 28px 0 28px;border:1px solid #e6e7ea;border-radius:12px;min-width:560px;max-width:720px;width:90vw;box-shadow:0 8px 28px rgba(16,24,40,.18);max-height:80vh;overflow-y:auto;display:flex;flex-direction:column;gap:12px}
        .bm-header{position:sticky;top:0;background:#fff;z-index:12;padding-bottom:12px;margin-bottom:0}
        .bm-title{margin:0 0 12px 0;font-size:20px;font-weight:800;letter-spacing:-.02em}
        .bm-field{display:flex;flex-direction:column;gap:8px}
        .bm-label{font-size:14px;font-weight:500;color:#374151}
        .bm-input{width:100%;padding:10px 12px;border-radius:4px;border:1px solid #dcdee2;background-color:#f3f5f7;box-shadow:0 2px 8px 0 rgba(0,0,0,0.02);font-size:12px;font-family:Inter,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif;box-sizing:border-box;min-height:40px}
        .bm-input:focus{outline:none;border-color:#3b82f6;box-shadow:0 0 0 3px rgba(59,130,246,0.1)}
        .bm-modal select.bm-input{overflow:visible;text-overflow:clip;white-space:normal}
        .bm-modal select.bm-input option{white-space:normal;word-wrap:break-word;padding:8px}
        .bm-actions{display:flex;gap:12px;justify-content:flex-end;margin-top:8px;position:sticky;bottom:0;background:#fff;padding-top:12px;padding-bottom:24px;z-index:10}
        .btn-outline,.btn-primary{padding:8px 16px;border-radius:10px;font-size:14px;line-height:20px;min-height:40px;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;transition:background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;cursor:pointer}
        .btn-outline{border:1px solid #d1d5db;background:#fff;color:#0f1720}
        .btn-outline:hover{background:#f1f5f9;box-shadow:0 0 0 2px rgba(99,102,241,0.1)}
        .btn-outline:active{transform:translateY(1px);}
        .btn-primary{border:none;background:#1761a5;color:#fff}
        .btn-primary:hover:not(:disabled){background:#0f4a7a;box-shadow:0 0 0 2px rgba(23,97,165,0.2)}
        .btn-primary:active:not(:disabled){transform:translateY(1px);}
        .btn-primary:disabled{opacity:0.6;cursor:not-allowed;box-shadow:none}
    </style>
}

@code {
    [Parameter] public bool IsOpen { get; set; }
    [Parameter] public EventCallback OnClose { get; set; }
    [Parameter] public EventCallback OnCopied { get; set; }

    private List<SchedulerMVP.Data.Entities.ScheduleTemplate> templates = new();
    private Guid? selectedTemplateId;
    private DateOnly startDate;
    private DateOnly endDate;
    private string startDateString => startDate.ToString("yyyy-MM-dd");
    private string endDateString => endDate.ToString("yyyy-MM-dd");

    protected override async Task OnParametersSetAsync()
    {
        if (IsOpen)
        {
            await LoadTemplates();
            startDate = UI.CurrentWeekStart; // default: aktuell vecka
            endDate = UI.CurrentWeekEnd;
        }
    }

    private async Task LoadTemplates()
    {
        templates = await TemplateService.GetTemplatesAsync();
        StateHasChanged();
    }

    private void OnTemplateChanged(ChangeEventArgs e)
    {
        if (Guid.TryParse(e.Value?.ToString(), out var id))
        {
            selectedTemplateId = id;
        }
        else
        {
            selectedTemplateId = null;
        }
        StateHasChanged();
    }

    private async Task OnCopy()
    {
        Console.WriteLine("[CalendarCopyTemplateModal] OnCopy called");
        
        if (!selectedTemplateId.HasValue)
        {
            Console.WriteLine("[CalendarCopyTemplateModal] No template selected");
            return;
        }
        
        if (endDate < startDate)
        {
            Console.WriteLine("[CalendarCopyTemplateModal] Invalid date range");
            return;
        }
        
        try
        {
            Console.WriteLine($"[CalendarCopyTemplateModal] Copying template {selectedTemplateId.Value} from {startDate} to {endDate}");
            
            var created = await CalendarBookingService.CopyTemplateToDateRangeAsync(selectedTemplateId.Value, startDate, endDate);
            
            Console.WriteLine($"[CalendarCopyTemplateModal] Created {created.Count} calendar bookings");
            
            if (created.Count == 0)
            {
                Console.WriteLine("[CalendarCopyTemplateModal] WARNING: No bookings were created. Template may not have bookings for the selected date range.");
            }
            
            // Reset selection
            selectedTemplateId = null;
            
            // Close modal first
            await CloseAsync();
            
            // Then trigger refresh callback after a short delay to ensure modal is closed
            await Task.Delay(100);
            
            if (OnCopied.HasDelegate)
            {
                await OnCopied.InvokeAsync();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[CalendarCopyTemplateModal] Error copying template: {ex.Message}");
            Console.WriteLine($"[CalendarCopyTemplateModal] Exception type: {ex.GetType().Name}");
            Console.WriteLine($"[CalendarCopyTemplateModal] Stack trace: {ex.StackTrace}");
            // Don't close modal on error - let user see the error and try again
            StateHasChanged();
        }
    }

    private void OnStartDateChanged(ChangeEventArgs e)
    {
        if (DateOnly.TryParse(e.Value?.ToString(), out var d))
        {
            startDate = d;
            StateHasChanged();
        }
    }
    
    private void OnEndDateChanged(ChangeEventArgs e)
    {
        if (DateOnly.TryParse(e.Value?.ToString(), out var d))
        {
            endDate = d;
            StateHasChanged();
        }
    }

    private async Task OnCancel()
    {
        await CloseAsync();
    }

    private async Task OnBackdrop(MouseEventArgs _)
    {
        await CloseAsync();
    }

    private async Task CloseAsync()
    {
        IsOpen = false;
        StateHasChanged();
        
        if (OnClose.HasDelegate)
        {
            await OnClose.InvokeAsync();
        }
    }
}
