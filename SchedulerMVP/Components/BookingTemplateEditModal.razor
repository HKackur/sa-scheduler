@using SchedulerMVP.Data.Entities
@using Microsoft.EntityFrameworkCore
@inject IDbContextFactory<SchedulerMVP.Data.AppDbContext> DbFactory
@inject SchedulerMVP.Services.UserContextService UserContext
@inject SchedulerMVP.Services.UIState UI
@inject SchedulerMVP.Services.IConflictService ConflictService
@inject SchedulerMVP.Services.IGroupService GroupService
@inject SchedulerMVP.Services.IPlaceService PlaceService

@if (IsOpen && EditingTemplate != null)
{
    <div class="modal-backdrop" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 2000;" @onclick="Close"></div>

    <div class="bm-modal" @onclick="CloseDropdowns" @onclick:stopPropagation="true">
        <div class="bm-modal-content">
        <div class="bm-header">
            <h2 class="bm-title">Ändra bokning</h2>
        </div>

        @* Group Selection *@
        <div class="bm-field">
            <label class="bm-label">Grupp</label>
            <select @bind="SelectedGroupId" @bind:event="onchange" class="bm-input">
                <option value="">Välj grupp</option>
                @if (groups != null)
                {
                    @foreach (var g in groups)
                    {
                        <option value="@g.Id">@g.Name</option>
                    }
                }
            </select>
        </div>

        @* Place Selection *@
        <div class="bm-field">
            <label class="bm-label">Plats</label>
            <div class="bm-custom-select" @onclick:stopPropagation="true">
                <div class="bm-custom-select-trigger" @onclick="TogglePlaceDropdown">
                    @if (SelectedPlaceId.HasValue && AvailablePlaces != null)
                    {
                        var selectedPlace = AvailablePlaces.FirstOrDefault(p => p.Id == SelectedPlaceId.Value);
                        if (selectedPlace != null)
                        {
                            <span class="bm-place-name">@selectedPlace.Name</span>
                        }
                    }
                    else
                    {
                        <span class="bm-placeholder">Välj plats</span>
                    }
                    <span class="bm-dropdown-icon @(showPlaceDropdown ? "open" : "")"></span>
                </div>
                
                @if (showPlaceDropdown && AvailablePlaces != null)
                {
                    <div class="bm-custom-select-dropdown">
                        @foreach (var place in AvailablePlaces)
                        {
                            var isSelected = SelectedPlaceId == place.Id;
                            <div class="bm-dropdown-option @(isSelected ? "selected" : "")" 
                                 @onclick="() => SelectPlace(place.Id)">
                                <span class="bm-place-name">@place.Name</span>
                            </div>
                        }
                    </div>
                }
            </div>
        </div>

        @* Area Selection *@
        <div class="bm-field">
            <label class="bm-label">Yta</label>
            <div class="bm-custom-select" @onclick:stopPropagation="true">
                <div class="bm-custom-select-trigger" @onclick="ToggleAreaDropdown" @onclick:stopPropagation="true">
                    @if (SelectedAreaId.HasValue && AvailableAreas != null)
                    {
                        var selectedArea = AvailableAreas.FirstOrDefault(a => a.Id == SelectedAreaId.Value);
                        if (selectedArea != null)
                        {
                            var isAvailable = GetAreaAvailability(selectedArea.Id);
                            <div class="bm-selected-area">
                                <span class="bm-availability-icon @(isAvailable ? "available" : "unavailable")"></span>
                                <span class="bm-area-name">@selectedArea.Name</span>
                                @if (!isAvailable)
                                {
                                    <span class="bm-unavailable-text">(Upptagen)</span>
                                }
                            </div>
                        }
                    }
                    else
                    {
                        <span class="bm-placeholder">Välj yta</span>
                    }
                    <span class="bm-dropdown-icon @(showAreaDropdown ? "open" : "")"></span>
                </div>
                
                @if (showAreaDropdown && AvailableAreas != null)
                {
                    <div class="bm-custom-select-dropdown">
                        @foreach (var area in AvailableAreas)
                        {
                            var isAvailable = GetAreaAvailability(area.Id);
                            var isSelected = SelectedAreaId == area.Id;
                            <div class="bm-dropdown-option @(isSelected ? "selected" : "") @(isAvailable ? "available" : "unavailable")" 
                                 @onclick="() => SelectArea(area.Id)">
                                <span class="bm-availability-icon @(isAvailable ? "available" : "unavailable")"></span>
                                <span class="bm-area-name">@area.Name</span>
                                @if (!isAvailable)
                                {
                                    <span class="bm-unavailable-text">(Upptagen)</span>
                                }
                            </div>
                        }
                    </div>
                }
            </div>
        </div>

        @* Day selection (single choice) *@
        <div class="bm-field">
            <div class="bm-days">
                @for (var checkboxDay = 1; checkboxDay <= 7; checkboxDay++)
                {
                    var dayIndex = checkboxDay;
                    var dayName = DayShort(dayIndex);
                    var isChecked = SelectedDay == dayIndex;
                    <div class="bm-day">
                        <div class="bm-day-label">@dayName</div>
                        <input class="bm-checkbox" type="checkbox" checked="@isChecked" @onchange="(e) => OnEditDayChanged(dayIndex, e.Value)" />
                    </div>
                }
            </div>
        </div>

        @* Time selection *@
        <div class="bm-field" @onclick:stopPropagation="true">
            <div class="bm-time-row">
                <div>
                    <label class="bm-label">Starttid</label>
                    <div class="bm-select-wrap">
                        <input type="time" value="@StartTime" @onchange="OnStartTimeChanged" @onclick:stopPropagation="true" class="bm-input" />
                    </div>
                </div>
                <div>
                    <label class="bm-label">Sluttid</label>
                    <div class="bm-select-wrap">
                        <input type="time" value="@EndTime" @onchange="OnEndTimeChanged" @onclick:stopPropagation="true" class="bm-input" />
                    </div>
                </div>
            </div>
        </div>
        @* Övrigt (toggle) *@
        <div class="bm-field" style="margin-top:12px;" @onclick:stopPropagation="true">
            <button type="button" @onclick="ToggleExtras" @onclick:stopPropagation="true" style="background:transparent;border:none;color:#0b1e34;cursor:pointer;padding:0;font-weight:600;text-align:left;">@(showExtras ? "Dölj alternativ" : "Fler alternativ")</button>
        </div>
        @if (showExtras)
        {
            <div class="bm-field">
                <div style="display:grid;gap:12px;grid-template-columns:1fr;">
                    <div>
                        <label class="bm-label">Notering</label>
                        <textarea class="bm-input" rows="3" @bind="Notes"></textarea>
                    </div>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">
                        <div>
                            <label class="bm-label">Kontaktperson</label>
                            <input class="bm-input" @bind="ContactName" />
                        </div>
                        <div>
                            <label class="bm-label">Telefon</label>
                            <input class="bm-input" @bind="ContactPhone" />
                        </div>
                    </div>
                    <div>
                        <label class="bm-label">E‑post</label>
                        <input class="bm-input" @bind="ContactEmail" />
                    </div>
                </div>
            </div>
        }
        @if (conflictMessages.Count > 0)
        {
            <div class="bm-field" style="margin-top:4px;">
                <div style="padding:10px 12px;border:1px solid #fecaca;background:#fff1f2;color:#7f1d1d;border-radius:10px;font-size:13px;">
                    <div style="font-weight:700;margin-bottom:4px;">Konflikt</div>
                    @foreach (var msg in conflictMessages)
                    {
                        <div>• @msg</div>
                    }
                </div>
            </div>
        }

        </div>
        @* Action Buttons *@
        <div class="bm-actions" @onclick:stopPropagation="true">
            <button type="button" @onclick="Delete" @onclick:stopPropagation="true" class="btn-danger">Ta bort</button>
            <button type="button" @onclick="Close" @onclick:stopPropagation="true" class="btn-outline">Avbryt</button>
            <button type="button" @onclick="Save" @onclick:stopPropagation="true" class="btn-primary" disabled="@hasConflicts">Spara</button>
        </div>
    </div>
}

@code {
    [Parameter] public bool IsOpen { get; set; }
    [Parameter] public Guid? TemplateId { get; set; }
    [Parameter] public EventCallback OnClose { get; set; }
    [Parameter] public EventCallback OnChanged { get; set; }

    private BookingTemplate? EditingTemplate;
    private string StartTime = "08:00";
    private string EndTime = "09:00";
    private List<string> timeOptions = new();
    private List<Group>? groups;
    private Guid? SelectedGroupId;
    private int SelectedDay;
    private string? placeName;
    private int currentDurationMinutes = 60; // Track current duration
    private bool isUpdatingTime = false; // Prevent recursive updates
    private bool hasConflicts = false;
    private List<string> conflictMessages = new();
    private string? Notes;
    private string? ContactName;
    private string? ContactPhone;
    private string? ContactEmail;
    private bool showExtras = false;
    
    // Place selection properties
    private Guid? SelectedPlaceId { get; set; }
    private List<Place>? AvailablePlaces;
    private bool showPlaceDropdown = false;
    
    // Area selection properties
    private Guid? SelectedAreaId { get; set; }
    private List<Area>? AvailableAreas;
    private Dictionary<Guid, bool> AreaAvailability = new();
    private bool showAreaDropdown = false;
    
    // Track modal state to detect when it's actually opened (not just parameter changes)
    private bool _wasOpen = false;

    protected override async Task OnParametersSetAsync()
    {
        try
        {
            // If modal was open but is now closed, reset the flag and fields
            if (!IsOpen && _wasOpen)
            {
                ResetAllFields();
                _wasOpen = false;
            }
            
            if (IsOpen && TemplateId.HasValue)
            {
                // CRITICAL: Reset fields when modal is actually being opened (was closed, now open)
                // This prevents showing stale data from the previous booking
                if (!_wasOpen)
                {
                    // Modal just opened - reset all fields to prevent showing stale data
                    ResetAllFields();
                }
                _wasOpen = true;
                
                await using var db = await DbFactory.CreateDbContextAsync();
                EditingTemplate = await db.BookingTemplates
                    .Include(b => b.Area)
                        .ThenInclude(a => a.Place)
                    .Include(b => b.Group)
                    .FirstOrDefaultAsync(b => b.Id == TemplateId.Value);

                if (EditingTemplate != null)
                {
                    // Build time options based on place snap (fallback 30 min)
                    // Use Place from Area navigation property (already loaded via ThenInclude)
                    var snap = 30;
                    if (EditingTemplate.Area?.Place != null)
                    {
                        if (EditingTemplate.Area.Place.SnapMin > 0) snap = EditingTemplate.Area.Place.SnapMin;
                        placeName = EditingTemplate.Area.Place.Name;
                    }
                    timeOptions = GenerateTimes(snap);
                    StartTime = MinutesToString(EditingTemplate.StartMin);
                    EndTime = MinutesToString(EditingTemplate.EndMin);
                    currentDurationMinutes = EditingTemplate.EndMin - EditingTemplate.StartMin;
                    SelectedGroupId = EditingTemplate.GroupId;
                    SelectedDay = EditingTemplate.DayOfWeek;

                    // Load groups and places in parallel for better performance
                    var groupsTask = GroupService.GetGroupsAsync();
                    var placesTask = PlaceService.GetPlacesAsync();
                    await Task.WhenAll(groupsTask, placesTask);
                    
                    groups = await groupsTask;
                    AvailablePlaces = await placesTask;
                    
                    // Set selected place and area, but defer loading areas until user opens dropdown
                    if (EditingTemplate.Area != null)
                    {
                        SelectedPlaceId = EditingTemplate.Area.PlaceId;
                        SelectedAreaId = EditingTemplate.Area.Id;
                        // Don't load areas here - load lazily when user opens area dropdown
                    }
                    Notes = EditingTemplate.Notes;
                    ContactName = EditingTemplate.ContactName;
                    ContactPhone = EditingTemplate.ContactPhone;
                    ContactEmail = EditingTemplate.ContactEmail;
                    // Auto-expand extras if any extra fields contain data
                    showExtras = !string.IsNullOrWhiteSpace(Notes)
                                 || !string.IsNullOrWhiteSpace(ContactName)
                                 || !string.IsNullOrWhiteSpace(ContactPhone)
                                 || !string.IsNullOrWhiteSpace(ContactEmail);
                    // Don't check conflicts on modal open - defer until user interaction
                }
            }
        }
        catch (Exception ex)
        {
            // CRITICAL: Catch all exceptions to prevent circuit crashes
            Console.WriteLine($"[BookingTemplateEditModal] Error in OnParametersSetAsync: {ex.Message}");
        }
    }

    private async Task OnStartTimeChanged(ChangeEventArgs e)
    {
        if (isUpdatingTime) return;
        
        StartTime = e.Value?.ToString() ?? "08:00";
        isUpdatingTime = true;
        // Update end time to maintain current duration
        EndTime = AddMinutesToTime(StartTime, currentDurationMinutes);
        isUpdatingTime = false;
        await RecheckConflictsAsync();
        await CheckAllAreasAvailabilityAsync();
        StateHasChanged();
    }
    
    private async Task OnEndTimeChanged(ChangeEventArgs e)
    {
        if (isUpdatingTime) return;
        
        EndTime = e.Value?.ToString() ?? "09:00";
        // Update current duration based on new end time
        currentDurationMinutes = GetDurationInMinutes(StartTime, EndTime);
        await RecheckConflictsAsync();
        await CheckAllAreasAvailabilityAsync();
        StateHasChanged();
    }
    
    private async Task LoadAvailablePlacesAsync()
    {
        try
        {
            // Use PlaceService for caching and consistent filtering (ClubId-based)
            Console.WriteLine($"[BookingTemplateEditModal] Loading places using PlaceService...");
            AvailablePlaces = await PlaceService.GetPlacesAsync();
            Console.WriteLine($"[BookingTemplateEditModal] Places loaded: {AvailablePlaces?.Count ?? 0} places");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[BookingTemplateEditModal] Error loading places: {ex.Message}");
        }
    }
    
    private async Task LoadAvailableAreasAsync()
    {
        if (!SelectedPlaceId.HasValue) return;
        
        try
        {
            await using var db = await DbFactory.CreateDbContextAsync();
            AvailableAreas = await db.Areas
                .Where(a => a.PlaceId == SelectedPlaceId.Value)
                .OrderBy(a => a.Path)
                .ToListAsync();
            
            await CheckAllAreasAvailabilityAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[BookingTemplateEditModal] Error loading areas: {ex.Message}");
        }
    }
    
    private async Task CheckAllAreasAvailabilityAsync()
    {
        if (AvailableAreas == null) return;
        
        AreaAvailability.Clear();
        
        // Parse current time selection
        var sp = StartTime.Split(':'); 
        var ep = EndTime.Split(':');
        var s = int.Parse(sp[0]) * 60 + int.Parse(sp[1]);
        var e = int.Parse(ep[0]) * 60 + int.Parse(ep[1]);
        
        foreach (var area in AvailableAreas)
        {
            bool isAvailable = true;
            
            if (UI.IsCalendarViewMode)
            {
                // Calendar mode: check conflicts for specific date
                var conflicts = await ConflictService.CheckAreaConflictsAsync(area.Id, SelectedDay, s, e, EditingTemplate?.Id, null);
                if (conflicts.Count > 0)
                {
                    isAvailable = false;
                }
            }
            else
            {
                // Weekplanner mode: check conflicts for selected day
                if (UI.SelectedTemplateId.HasValue)
                {
                    var conflicts = await ConflictService.CheckAreaConflictsAsync(area.Id, SelectedDay, s, e, EditingTemplate?.Id, UI.SelectedTemplateId.Value);
                    if (conflicts.Count > 0)
                    {
                        isAvailable = false;
                    }
                }
            }
            
            AreaAvailability[area.Id] = isAvailable;
        }
    }
    
    private bool GetAreaAvailability(Guid areaId)
    {
        return AreaAvailability.TryGetValue(areaId, out bool isAvailable) ? isAvailable : true;
    }
    
    private void TogglePlaceDropdown()
    {
        showPlaceDropdown = !showPlaceDropdown;
        StateHasChanged();
    }
    
    private async Task ToggleAreaDropdown()
    {
        // Load areas lazily when dropdown is opened for the first time
        if (!showAreaDropdown && AvailableAreas == null && SelectedPlaceId.HasValue)
        {
            await LoadAvailableAreasAsync();
        }
        
        if (!showAreaDropdown && AvailableAreas != null)
        {
            await CheckAllAreasAvailabilityAsync();
        }
        showAreaDropdown = !showAreaDropdown;
        StateHasChanged();
    }
    
    private async Task SelectPlace(Guid placeId)
    {
        SelectedPlaceId = placeId;
        showPlaceDropdown = false;
        
        // Clear selected area when place changes
        SelectedAreaId = null;
        AvailableAreas = null;
        
        // Load areas for the new place
        await LoadAvailableAreasAsync();
        
        await CheckAllAreasAvailabilityAsync();
        await RecheckConflictsAsync();
        StateHasChanged();
    }
    
    private async Task SelectArea(Guid areaId)
    {
        SelectedAreaId = areaId;
        showAreaDropdown = false;
        
        await CheckAllAreasAvailabilityAsync();
        await RecheckConflictsAsync();
        StateHasChanged();
    }
    
    private string AddMinutesToTime(string time, int minutes)
    {
        var parts = time.Split(':');
        var totalMinutes = int.Parse(parts[0]) * 60 + int.Parse(parts[1]) + minutes;
        var hours = totalMinutes / 60;
        var mins = totalMinutes % 60;
        
        // Handle day overflow
        if (hours >= 24)
        {
            hours = hours % 24;
        }
        
        return $"{hours:00}:{mins:00}";
    }
    
    private int GetDurationInMinutes(string startTime, string endTime)
    {
        var startParts = startTime.Split(':');
        var endParts = endTime.Split(':');
        var startMinutes = int.Parse(startParts[0]) * 60 + int.Parse(startParts[1]);
        var endMinutes = int.Parse(endParts[0]) * 60 + int.Parse(endParts[1]);
        
        // Handle day overflow
        if (endMinutes < startMinutes)
        {
            endMinutes += 24 * 60; // Add 24 hours
        }
        
        return endMinutes - startMinutes;
    }

    private async Task Save()
    {
        try
        {
            if (EditingTemplate == null) return;
            if (hasConflicts) return;
            
            await using var db = await DbFactory.CreateDbContextAsync();
            // Reload the entity in the new context
            var template = await db.BookingTemplates.FindAsync(EditingTemplate.Id);
            if (template == null) return;
            
            var (s, e) = ParseTimes(StartTime, EndTime);
            template.StartMin = s;
            template.EndMin = e;
            if (SelectedGroupId.HasValue) template.GroupId = SelectedGroupId.Value;
            if (SelectedAreaId.HasValue) template.AreaId = SelectedAreaId.Value;
            if (SelectedDay < 1) SelectedDay = 1; if (SelectedDay > 7) SelectedDay = 7; template.DayOfWeek = SelectedDay;
            template.Notes = string.IsNullOrWhiteSpace(Notes) ? null : Notes;
            template.ContactName = ContactName;
            template.ContactPhone = ContactPhone;
            template.ContactEmail = ContactEmail;
            template.UpdatedAt = DateTime.UtcNow;
            await db.SaveChangesAsync();
            await OnChanged.InvokeAsync();
            await Close();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[BookingTemplateEditModal] Error saving: {ex.Message}");
        }
        finally
        {
            StateHasChanged();
        }
    }

    private async Task Delete()
    {
        try
        {
            if (EditingTemplate == null) return;
            await using var db = await DbFactory.CreateDbContextAsync();
            var template = await db.BookingTemplates.FindAsync(EditingTemplate.Id);
            if (template != null)
            {
                db.BookingTemplates.Remove(template);
                await db.SaveChangesAsync();
            }
            await OnChanged.InvokeAsync();
            await Close();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[BookingTemplateEditModal] Error deleting: {ex.Message}");
        }
        finally
        {
            StateHasChanged();
        }
    }

    private async Task Close()
    {
        try
        {
            // CRITICAL: Reset all fields when modal closes to prevent stale data on next open
            ResetAllFields();
            _wasOpen = false;
            
            await OnClose.InvokeAsync();
        }
        catch (Exception ex)
        {
            // CRITICAL: Never throw from Close - log and try to close anyway
            Console.WriteLine($"[BookingTemplateEditModal] Error in Close: {ex.Message}");
            _wasOpen = false;
            try
            {
                await OnClose.InvokeAsync();
            }
            catch
            {
                // If OnClose fails, at least mark as closed
            }
        }
    }
    
    /// <summary>
    /// Resets all form fields to their default values to prevent stale data from showing
    /// when the modal is opened again. This eliminates the "blink" effect showing old data.
    /// CRITICAL: This method must never throw exceptions to prevent circuit crashes.
    /// </summary>
    private void ResetAllFields()
    {
        try
        {
            // Reset template and editing state
            EditingTemplate = null;
            
            // Reset time fields
            StartTime = "08:00";
            EndTime = "09:00";
            currentDurationMinutes = 60;
            timeOptions = new List<string>();
            
            // Reset selection fields
            SelectedGroupId = null;
            SelectedDay = 0;
            SelectedPlaceId = null;
            SelectedAreaId = null;
            placeName = null;
            
            // Reset contact/notes fields
            Notes = null;
            ContactName = null;
            ContactPhone = null;
            ContactEmail = null;
            showExtras = false;
            
            // Reset conflict/state fields
            hasConflicts = false;
            if (conflictMessages == null)
            {
                conflictMessages = new List<string>();
            }
            else
            {
                conflictMessages.Clear();
            }
            
            // Reset UI state
            showAreaDropdown = false;
            showPlaceDropdown = false;
            if (AreaAvailability == null)
            {
                AreaAvailability = new Dictionary<Guid, bool>();
            }
            else
            {
                AreaAvailability.Clear();
            }
            
            // Note: We don't reset groups, AvailablePlaces, AvailableAreas here
            // as they will be reloaded in OnParametersSetAsync anyway
            // But we set them to null to ensure UI shows empty state until new data loads
            groups = null;
            AvailablePlaces = null;
            AvailableAreas = null;
        }
        catch (Exception ex)
        {
            // CRITICAL: Never throw from ResetAllFields - log and continue
            Console.WriteLine($"[BookingTemplateEditModal] Error in ResetAllFields: {ex.Message}");
        }
    }

    private static (int start, int end) ParseTimes(string start, string end)
    {
        var sp = start.Split(':');
        var ep = end.Split(':');
        var s = int.Parse(sp[0]) * 60 + int.Parse(sp[1]);
        var e = int.Parse(ep[0]) * 60 + int.Parse(ep[1]);
        if (e <= s) e = s + 30; // guard minimal range
        return (s, e);
    }

    private static string MinutesToString(int m)
    {
        var h = m / 60; var mm = m % 60; return $"{h:00}:{mm:00}";
    }

    private static string DayName(int d) => new[] {"","Måndag","Tisdag","Onsdag","Torsdag","Fredag","Lördag","Söndag"}[d];
    private static string DayShort(int d) => new[] {"","Mån","Tis","Ons","Tor","Fre","Lör","Sön"}[d];

    private async Task OnEditDayChanged(int day, object? value)
    {
        if (value is bool isChecked)
        {
            if (isChecked) SelectedDay = day; else if (SelectedDay == day) SelectedDay = 0;
            await CheckAllAreasAvailabilityAsync();
            await RecheckConflictsAsync();
            StateHasChanged();
        }
    }

    private static List<string> GenerateTimes(int stepMin)
    {
        var list = new List<string>();
        for (var m = 0; m < 24 * 60; m += Math.Max(5, stepMin))
        {
            list.Add(MinutesToString(m));
        }
        list.Add("24:00"); // allow selecting end at midnight
        return list;
    }
}

@code {
    private async Task RecheckConflictsAsync()
    {
        conflictMessages.Clear(); hasConflicts = false;
        var areaId = SelectedAreaId ?? EditingTemplate?.Area?.Id;
        if (areaId == null) { StateHasChanged(); return; }
        var (s,e) = ParseTimes(StartTime, EndTime);
        var day = SelectedDay > 0 ? SelectedDay : EditingTemplate?.DayOfWeek ?? 1;
        var conflicts = await ConflictService.CheckAreaConflictsAsync(areaId.Value, day, s, e, EditingTemplate?.Id, EditingTemplate?.ScheduleTemplateId);
        if (conflicts.Count > 0)
        {
            hasConflicts = true;
            foreach (var c in conflicts)
            {
                var from = $"{c.StartMin/60:00}:{c.StartMin%60:00}"; var to = $"{c.EndMin/60:00}:{c.EndMin%60:00}";
                conflictMessages.Add($"{DayShort(c.DayOfWeek)} • {from}-{to} • {c.OtherAreaName} ({c.OtherGroupName})");
            }
        }
        StateHasChanged();
    }
    private void ToggleExtras()
    {
        showExtras = !showExtras;
        StateHasChanged();
    }
    
    private void CloseDropdowns()
    {
        showPlaceDropdown = false;
        showAreaDropdown = false;
        StateHasChanged();
    }
}


