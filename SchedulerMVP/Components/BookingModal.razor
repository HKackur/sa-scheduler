@using SchedulerMVP.Data.Entities
@using Microsoft.EntityFrameworkCore
@using System.Threading
@inject IDbContextFactory<SchedulerMVP.Data.AppDbContext> DbFactory
@inject SchedulerMVP.Services.UserContextService UserContext
@inject SchedulerMVP.Services.UIState UI
@inject SchedulerMVP.Services.IGroupService GroupService
@inject SchedulerMVP.Services.IPlaceService PlaceService
@inject SchedulerMVP.Services.IConflictService ConflictService
@inject SchedulerMVP.Services.ToastService ToastService

@if (IsOpen)
{
    <div class="modal-backdrop" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 2000;" @onclick="CloseModal"></div>
    
    <div class="bm-modal" @onclick="CloseAreaDropdown">
        <div class="bm-header">
            <h2 class="bm-title">Skapa bokning</h2>
        </div>
        <div class="bm-modal-content">
        @* Loading indicator while groups are loading *@
        @if (Groups == null)
        {
            <div style="padding: 20px; text-align: center; color: #6b7280;">
                <div style="display: inline-block; width: 20px; height: 20px; border: 2px solid #e5e7eb; border-top-color: #3b82f6; border-radius: 50%; animation: booking-modal-spin 0.6s linear infinite;"></div>
                <div style="margin-top: 8px; font-size: 14px;">Laddar...</div>
            </div>
        }
        else
        {
            @* Group Selection *@
        <div class="bm-field">
            <label class="bm-label">Grupp</label>
            <select @bind="SelectedGroupId" @bind:event="onchange" class="bm-input">
                <option value="">Välj grupp</option>
                @if (Groups != null)
                {
                    @foreach (var group in Groups)
                    {
                        <option value="@group.Id">@group.Name</option>
                    }
                }
            </select>
        </div>
        
        @* Place Selection *@
        <div class="bm-field">
            <label class="bm-label">Plats</label>
            <div class="bm-custom-select" @onclick:stopPropagation="true">
                <div class="bm-custom-select-trigger" @onclick="TogglePlaceDropdown">
                    @if (SelectedPlaceId.HasValue && AvailablePlaces != null)
                    {
                        var selectedPlace = AvailablePlaces.FirstOrDefault(p => p.Id == SelectedPlaceId.Value);
                        if (selectedPlace != null)
                        {
                            <span class="bm-place-name">@selectedPlace.Name</span>
                        }
                    }
                    else
                    {
                        <span class="bm-placeholder">Välj plats</span>
                    }
                    <span class="bm-dropdown-icon @(showPlaceDropdown ? "open" : "")"></span>
                </div>
                
                @if (showPlaceDropdown && AvailablePlaces != null)
                {
                    <div class="bm-custom-select-dropdown">
                        @foreach (var place in AvailablePlaces)
                        {
                            var isSelected = SelectedPlaceId == place.Id;
                            <div class="bm-dropdown-option @(isSelected ? "selected" : "")" 
                                 @onclick="() => SelectPlace(place.Id)">
                                <span class="bm-place-name">@place.Name</span>
                            </div>
                        }
                    </div>
                }
            </div>
        </div>
        
        @* Area Selection *@
        <div class="bm-field">
            <label class="bm-label">Yta</label>
            <div class="bm-custom-select" @onclick:stopPropagation="true">
                <div class="bm-custom-select-trigger" @onclick="() => ToggleAreaDropdown()" @onclick:stopPropagation="true">
                    @if (SelectedAreaId.HasValue && AvailableAreas != null)
                    {
                        var selectedArea = AvailableAreas.FirstOrDefault(a => a.Id == SelectedAreaId.Value);
                        if (selectedArea != null)
                        {
                            var isAvailable = GetAreaAvailability(selectedArea.Id);
                            <div class="bm-selected-area">
                                <span class="bm-availability-icon @(isAvailable ? "available" : "unavailable")"></span>
                                <span class="bm-area-name">@selectedArea.Name</span>
                                @if (!isAvailable)
                                {
                                    <span class="bm-unavailable-text">(Upptagen)</span>
                                }
                            </div>
                        }
                    }
                    else
                    {
                        <span class="bm-placeholder">Välj yta</span>
                    }
                    <span class="bm-dropdown-icon @(showAreaDropdown ? "open" : "")"></span>
                </div>
                
                @if (showAreaDropdown && AvailableAreas != null)
                {
                    <div class="bm-custom-select-dropdown">
                        @foreach (var area in AvailableAreas)
                        {
                            var isAvailable = GetAreaAvailability(area.Id);
                            var isSelected = SelectedAreaId == area.Id;
                            <div class="bm-dropdown-option @(isSelected ? "selected" : "") @(isAvailable ? "available" : "unavailable")" 
                                 @onclick="() => SelectArea(area.Id)">
                                <span class="bm-availability-icon @(isAvailable ? "available" : "unavailable")"></span>
                                <span class="bm-area-name">@area.Name</span>
                                @if (!isAvailable)
                                {
                                    <span class="bm-unavailable-text">(Upptagen)</span>
                                }
                            </div>
                        }
                    </div>
                }
            </div>
        </div>

        @* Day Selection - Different for Calendar vs Weekplanner mode *@
        @if (UI.IsCalendarViewMode)
        {
            @* Calendar mode: Date picker *@
            <div class="bm-field">
                <label class="bm-label">Datum</label>
                <input type="date" @bind="SelectedDate" class="bm-input" />
            </div>
        }
        else
        {
            @* Weekplanner mode: Weekday picker *@
            <div class="bm-field">
                <div class="bm-days">
                    @for (var checkboxDay = 1; checkboxDay <= 7; checkboxDay++)
                    {
                        var dayIndex = checkboxDay; // capture per-iteration to avoid closure bug
                        var dayName = GetDayName(dayIndex);
                        var isChecked = SelectedDays.Contains(dayIndex);
                        <div class="bm-day">
                            <div class="bm-day-label">@dayName</div>
                            <input class="bm-checkbox" type="checkbox" checked="@isChecked" @onchange="(e) => OnDayCheckboxChanged(dayIndex, e.Value)" />
                        </div>
                    }
                </div>
            </div>
        }

        @* Time Selection - visa olika tider per dag om flera dagar är valda *@
        @if (!UI.IsCalendarViewMode && SelectedDays.Count > 1)
        {
            @foreach (var day in GetSortedSelectedDays())
            {
                var dayName = GetDayName(day);
                var (dayStartTime, dayEndTime) = DayTimes.ContainsKey(day) ? DayTimes[day] : (StartTime, EndTime);
                <div class="bm-field" @onclick:stopPropagation="true">
                    <div class="bm-time-row">
                        <div>
                            <label class="bm-label">
                                <span style="font-weight: 600; color: #1f2937;">@dayName</span> Starttid
                            </label>
                            <div class="bm-select-wrap">
                                <input type="time" value="@dayStartTime" @onchange="(e) => OnDayStartTimeChanged(day, e)" @onclick:stopPropagation="true" class="bm-input" />
                            </div>
                        </div>
                        <div>
                            <label class="bm-label">Sluttid</label>
                            <div class="bm-select-wrap">
                                <input type="time" value="@dayEndTime" @onchange="(e) => OnDayEndTimeChanged(day, e)" @onclick:stopPropagation="true" class="bm-input" />
                            </div>
                        </div>
                    </div>
                </div>
            }
        }
        else
        {
            @* Original time selection när bara en dag är vald eller kalendervy *@
            <div class="bm-field" @onclick:stopPropagation="true">
                <div class="bm-time-row">
                    <div>
                        <label class="bm-label">Starttid</label>
                        <div class="bm-select-wrap">
                            <input type="time" value="@StartTime" @onchange="OnStartTimeChanged" @onclick:stopPropagation="true" class="bm-input" />
                        </div>
                    </div>
                    <div>
                        <label class="bm-label">Sluttid</label>
                        <div class="bm-select-wrap">
                            <input type="time" value="@EndTime" @onchange="OnEndTimeChanged" @onclick:stopPropagation="true" class="bm-input" />
                        </div>
                    </div>
                </div>
            </div>
        }
        
        @if (conflictMessages.Count > 0)
        {
            <div class="bm-field" style="margin-top:4px;">
                <div style="padding:10px 12px;border:1px solid #fecaca;background:#fff1f2;color:#7f1d1d;border-radius:10px;font-size:13px;">
                    <div style="font-weight:700;margin-bottom:4px;">Konflikt</div>
                    @foreach (var msg in conflictMessages)
                    {
                        <div>• @msg</div>
                    }
                </div>
            </div>
        }
        
        @* Övrigt (toggle) *@
        <div class="bm-field" style="margin-top:12px;" @onclick:stopPropagation="true">
            <button type="button" @onclick="ToggleExtras" @onclick:stopPropagation="true" style="background:transparent;border:none;color:#0b1e34;cursor:pointer;padding:0;font-weight:600;text-align:left;font-size:14px;">@(showExtras ? "Dölj alternativ" : "Fler alternativ")</button>
        </div>
        @if (showExtras)
        {
            <div class="bm-field">
                <div style="display:grid;gap:12px;grid-template-columns:1fr;">
                    <div>
                        <label class="bm-label">Notering</label>
                        <textarea class="bm-input" rows="3" @bind="Notes"></textarea>
                    </div>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">
                        <div>
                            <label class="bm-label">Kontaktperson</label>
                            <input class="bm-input" @bind="ContactName" />
                        </div>
                        <div>
                            <label class="bm-label">Telefon</label>
                            <input class="bm-input" @bind="ContactPhone" />
                        </div>
                    </div>
                    <div>
                        <label class="bm-label">E‑post</label>
                        <input class="bm-input" @bind="ContactEmail" />
                    </div>
                </div>
            </div>
        }
        }
        </div>
        @* Action Buttons *@
        <div class="bm-actions" @onclick:stopPropagation="true">
            <button type="button" @onclick="CloseModal" @onclick:stopPropagation="true" class="btn-outline">Avbryt</button>
            <button type="button" @onclick="SaveBookingTemplate" @onclick:stopPropagation="true" class="btn-primary" disabled="@(hasConflicts || saveInProgress)">Spara</button>
        </div>
    </div>
}

@code {
    [Parameter] public bool IsOpen { get; set; }
    [Parameter] public Area? SelectedArea { get; set; }
    [Parameter] public Place? SelectedPlace { get; set; }
    [Parameter] public EventCallback OnClose { get; set; }
    [Parameter] public EventCallback OnSave { get; set; }
    [Parameter] public string? PrefilledStartTime { get; set; }
    [Parameter] public string? PrefilledEndTime { get; set; }
    [Parameter] public Guid? PrefilledGroupId { get; set; }
    [Parameter] public int? PrefilledDay { get; set; }
    
    private List<int> SelectedDays { get; set; } = new();
    private Dictionary<int, (string start, string end)> DayTimes { get; set; } = new(); // Tider per veckodag
    private Guid? SelectedGroupId { get; set; }
    private DateTime SelectedDate { get; set; } = DateTime.Today;
    private string StartTime { get; set; } = "08:00";
    private string EndTime { get; set; } = "09:00";
    private List<Group>? Groups;
    private int currentDurationMinutes = 60; // Track current duration
    private bool isUpdatingTime = false; // Prevent recursive updates
    private bool hasConflicts = false;
    private List<string> conflictMessages = new();
    private bool saveInProgress = false;
    private string? Notes;
    private string? ContactName;
    private string? ContactPhone;
    private string? ContactEmail;
    private bool showExtras = false;
    
    // Place selection properties
    private Guid? SelectedPlaceId { get; set; }
    private List<Place>? AvailablePlaces;
    private bool showPlaceDropdown = false;
    
    // Area selection properties
    private Guid? SelectedAreaId { get; set; }
    private List<Area>? AvailableAreas;
    private Dictionary<Guid, bool> AreaAvailability = new();
    private bool showAreaDropdown = false;
    
    // Semaphore to prevent concurrent availability checks and race conditions
    private readonly SemaphoreSlim availabilityCheckLock = new SemaphoreSlim(1, 1);
    
    // Track previous IsOpen state to detect when modal is actually opened (not just parameter changes)
    private bool _wasOpen = false;
    
    protected override async Task OnParametersSetAsync()
    {
        try
        {
            // If modal was open but is now closed, reset the flag and fields
            if (!IsOpen && _wasOpen)
            {
                ResetAllFields();
                _wasOpen = false;
                // Don't return early - let the method complete to ensure component state is valid
            }
            
            if (IsOpen)
            {
                // CRITICAL: Only reset fields when modal is actually being opened (was closed, now open)
                // This prevents resetting fields if parameters change while modal is already open
                if (!_wasOpen)
                {
                    // Modal just opened - reset all fields to prevent showing stale data
                    ResetAllFields();
                }
                _wasOpen = true;
                
                // Set the initially selected place (default to the place the user clicked on)
                // This must be set BEFORE loading areas, as LoadAvailableAreasAsync depends on SelectedPlaceId
                // CRITICAL: UI.SelectedAreaId is the source of truth - use it to find the correct place
                // This ensures correct values even if parent component has stale data
                if (UI.SelectedAreaId.HasValue)
                {
                    // Find the place that contains the selected area - this ensures we use the current area
                    try
                    {
                        var allPlaces = await PlaceService.GetPlacesAsync();
                        foreach (var place in allPlaces)
                        {
                            var areas = await PlaceService.GetAreasForPlaceAsync(place.Id);
                            if (areas.Any(a => a.Id == UI.SelectedAreaId.Value))
                            {
                                SelectedPlaceId = place.Id;
                                break;
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[BookingModal] Error finding place for area: {ex.Message}");
                        // Fallback to SelectedPlace parameter if available
                        if (SelectedPlace != null)
                        {
                            SelectedPlaceId = SelectedPlace.Id;
                        }
                    }
                }
                else if (SelectedPlace != null)
                {
                    // No selected area in UI - use SelectedPlace parameter
                    SelectedPlaceId = SelectedPlace.Id;
                }
                
                // Load groups from database FIRST - we need them before setting SelectedGroupId
                await LoadGroupsAsync();
                
                // Preselect group: Always use UI.FilteredGroupId if group filter is active
                // This is the same value used to filter the week view
                if (UI.IsGroupFilterActive && UI.FilteredGroupId.HasValue)
                {
                    SelectedGroupId = UI.FilteredGroupId;
                }
                else if (PrefilledGroupId.HasValue)
                {
                    SelectedGroupId = PrefilledGroupId;
                }
                else
                {
                    SelectedGroupId = null;
                }
                
                // Force UI update to reflect selected group
                StateHasChanged();
                
                // Load available places
                await LoadAvailablePlacesAsync();
                
                // Load available areas for the place (now that SelectedPlaceId is set)
                await LoadAvailableAreasAsync();
                
                // Set the initially selected area
                // This must be set AFTER loading areas, so AvailableAreas is populated
                // CRITICAL: Always use UI.SelectedAreaId as the source of truth
                // This ensures correct values even if parent component has stale data
                if (UI.SelectedAreaId.HasValue && AvailableAreas != null)
                {
                    // UI.SelectedAreaId is the source of truth - use it if available in the list
                    var areaInList = AvailableAreas.FirstOrDefault(a => a.Id == UI.SelectedAreaId.Value);
                    if (areaInList != null)
                    {
                        SelectedAreaId = UI.SelectedAreaId.Value;
                    }
                }
                else if (SelectedArea != null)
                {
                    // Fallback to SelectedArea parameter if UI.SelectedAreaId is not set
                    SelectedAreaId = SelectedArea.Id;
                }
                
                // Reset selected days
                SelectedDays.Clear();
                DayTimes.Clear();
                
                // Pre-fill day if provided (Weekplanner mode)
                if (PrefilledDay.HasValue && PrefilledDay.Value >= 1 && PrefilledDay.Value <= 7)
                {
                    SelectedDays.Add(PrefilledDay.Value);
                }
                
                // Initialize date for Calendar mode
                if (UI.IsCalendarViewMode)
                {
                    // Set to a date from the current week being displayed
                    // If PrefilledDay is provided, use that day of the current week
                    if (PrefilledDay.HasValue && PrefilledDay.Value >= 1 && PrefilledDay.Value <= 7)
                    {
                        var currentWeekStart = UI.CurrentWeekStart;
                        SelectedDate = currentWeekStart.AddDays(PrefilledDay.Value - 1).ToDateTime(TimeOnly.MinValue);
                    }
                    else
                    {
                        // Default to Monday of current week
                        SelectedDate = UI.CurrentWeekStart.ToDateTime(TimeOnly.MinValue);
                    }
                }
                
                // Initialize times based on place default duration
                if (SelectedPlace != null)
                {
                    currentDurationMinutes = SelectedPlace.DefaultDurationMin;
                    
                    // Use prefilled times if provided, otherwise use defaults
                    StartTime = !string.IsNullOrEmpty(PrefilledStartTime) ? PrefilledStartTime : "08:00";
                    if (!string.IsNullOrEmpty(PrefilledEndTime))
                    {
                        EndTime = PrefilledEndTime!;
                        currentDurationMinutes = GetDurationInMinutes(StartTime, EndTime);
                    }
                    else
                    {
                        EndTime = AddMinutesToTime(StartTime, currentDurationMinutes);
                    }
                }
                else
                {
                    // Fallback if SelectedPlace is null
                    StartTime = !string.IsNullOrEmpty(PrefilledStartTime) ? PrefilledStartTime : "08:00";
                    EndTime = !string.IsNullOrEmpty(PrefilledEndTime) ? PrefilledEndTime : "09:00";
                }
                
                // Check availability for ALL areas in the dropdown after all parameters are set
                // This ensures the availability indicators are correct from the start
                // Wrap in try-catch to prevent circuit crashes
                try
                {
                    await CheckAllAreasAvailabilityAsync();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[BookingModal] Error checking availability: {ex.Message}");
                }
                
                // Then check conflicts for the selected area
                try
                {
                    await RecheckConflictsAsync();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[BookingModal] Error checking conflicts: {ex.Message}");
                }
            }
        }
        catch (Exception ex)
        {
            // CRITICAL: Catch all exceptions to prevent circuit crashes
            // Log error but don't re-throw - component should still render
            Console.WriteLine($"[BookingModal] Error in OnParametersSetAsync: {ex.Message}");
            Console.WriteLine($"[BookingModal] Stack trace: {ex.StackTrace}");
        }
    }
    
    private async Task LoadGroupsAsync()
    {
        try
        {
            // Use GroupService for caching and consistent filtering
            Groups = await GroupService.GetGroupsAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[BookingModal] Error loading groups: {ex.Message}");
        }
    }
    
    private async Task LoadAvailablePlacesAsync()
    {
        try
        {
            // Use PlaceService for caching
            AvailablePlaces = await PlaceService.GetPlacesAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[BookingModal] Error loading places: {ex.Message}");
        }
    }
    
    private async Task LoadAvailableAreasAsync()
    {
        if (!SelectedPlaceId.HasValue) return;
        
        try
        {
            // Use PlaceService for caching
            AvailableAreas = await PlaceService.GetAreasForPlaceAsync(SelectedPlaceId.Value);
            
            // Check availability for all areas
            await CheckAllAreasAvailabilityAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[BookingModal] Error loading areas: {ex.Message}");
        }
    }
    
    private async Task CheckAllAreasAvailabilityAsync()
    {
        // Use semaphore to ensure only one availability check runs at a time
        // This prevents race conditions and ensures UI updates are consistent
        await availabilityCheckLock.WaitAsync();
        try
        {
            if (AvailableAreas == null) return;
            
            // Don't check availability if we don't have the required parameters
            // For Calendar mode: need SelectedDate
            // For Weekplanner mode: need SelectedTemplateId and SelectedDays
            if (UI.IsCalendarViewMode)
            {
                if (SelectedDate == default(DateTime))
                {
                    // Can't check availability without a date
                    return;
                }
            }
            else
            {
                if (!UI.SelectedTemplateId.HasValue || SelectedDays.Count == 0)
                {
                    // Can't check availability without template and days
                    // Default all to available for now
                    foreach (var area in AvailableAreas)
                    {
                        AreaAvailability[area.Id] = true;
                    }
                    return;
                }
            }
            
            AreaAvailability.Clear();
            
            // Parse current time selection
            var sp = StartTime.Split(':'); 
            var ep = EndTime.Split(':');
            var s = int.Parse(sp[0]) * 60 + int.Parse(sp[1]);
            var e = int.Parse(ep[0]) * 60 + int.Parse(ep[1]);
            
            // CRITICAL: Create copies to avoid "Collection was modified" errors during iteration
            var areasCopy = AvailableAreas.ToList(); // Create a snapshot
            var selectedDaysCopy = SelectedDays.ToList(); // Create a snapshot
            
            foreach (var area in areasCopy)
            {
                bool isAvailable = true;
                
                if (UI.IsCalendarViewMode)
                {
                    // Check calendar conflicts for the selected date
                    var conflicts = await ConflictService.CheckCalendarConflictsAsync(area.Id, DateOnly.FromDateTime(SelectedDate), s, e, null);
                    isAvailable = conflicts.Count == 0;
                }
                else
                {
                    // Check template conflicts for selected days
                    // We already verified SelectedTemplateId and SelectedDays.Count > 0 above
                    // Use copy to avoid "Collection was modified" errors
                    foreach (var day in selectedDaysCopy)
                    {
                        var conflicts = await ConflictService.CheckAreaConflictsAsync(area.Id, day, s, e, null, UI.SelectedTemplateId!.Value);
                        if (conflicts.Count > 0)
                        {
                            isAvailable = false;
                            break; // Once a conflict is found, mark as unavailable
                        }
                    }
                }
                
                AreaAvailability[area.Id] = isAvailable;
            }
            
            // Force UI update after availability is checked
            StateHasChanged();
        }
        finally
        {
            availabilityCheckLock.Release();
        }
    }
    
    private bool GetAreaAvailability(Guid areaId)
    {
        return AreaAvailability.TryGetValue(areaId, out bool isAvailable) ? isAvailable : true;
    }
    
    private async Task ToggleAreaDropdown()
    {
        // Before opening dropdown, ALWAYS refresh availability to ensure it's up-to-date
        // This ensures availability is correct even if modals was opened without PrefilledDay
        if (!showAreaDropdown && AvailableAreas != null)
        {
            // Force refresh availability before showing dropdown
            // StateHasChanged() is called internally by CheckAllAreasAvailabilityAsync()
            await CheckAllAreasAvailabilityAsync();
        }
        showAreaDropdown = !showAreaDropdown;
        StateHasChanged();
    }
    
    private void CloseAreaDropdown()
    {
        showAreaDropdown = false;
        showPlaceDropdown = false;
        StateHasChanged();
    }
    
    private async Task SelectArea(Guid areaId)
    {
        SelectedAreaId = areaId;
        showAreaDropdown = false;
        
        if (AvailableAreas != null)
        {
            var newArea = AvailableAreas.FirstOrDefault(a => a.Id == areaId);
            if (newArea != null)
            {
                // We need to update the parent component's SelectedArea
                // This will be handled by the OnSave method
            }
        }
        
        // Recheck all areas availability when area is selected, then check conflicts
        // StateHasChanged() is called by CheckAllAreasAvailabilityAsync() and RecheckConflictsAsync()
        await CheckAllAreasAvailabilityAsync();
        await RecheckConflictsAsync();
    }
    
    private void TogglePlaceDropdown()
    {
        showPlaceDropdown = !showPlaceDropdown;
        StateHasChanged();
    }
    
    private void ClosePlaceDropdown()
    {
        showPlaceDropdown = false;
        StateHasChanged();
    }
    
    private async Task SelectPlace(Guid placeId)
    {
        SelectedPlaceId = placeId;
        showPlaceDropdown = false;
        
        // Clear selected area when place changes
        SelectedAreaId = null;
        AvailableAreas = null;
        
        // Load areas for the new place
        await LoadAvailableAreasAsync();
        
        await RecheckConflictsAsync();
        StateHasChanged();
    }
    
    private async Task OnStartTimeChanged(ChangeEventArgs e)
    {
        if (isUpdatingTime) return;
        
        StartTime = e.Value?.ToString() ?? "08:00";
        // Update end time to maintain current duration
        EndTime = AddMinutesToTime(StartTime, currentDurationMinutes);
        // Check all areas first, then check conflicts (conflict check also updates availability for selected area)
        // StateHasChanged() is called by CheckAllAreasAvailabilityAsync() and RecheckConflictsAsync()
        await CheckAllAreasAvailabilityAsync();
        await RecheckConflictsAsync();
    }

    private async Task OnEndTimeChanged(ChangeEventArgs e)
    {
        if (isUpdatingTime) return;
        
        EndTime = e.Value?.ToString() ?? "09:00";
        // Update current duration based on new end time
        currentDurationMinutes = GetDurationInMinutes(StartTime, EndTime);
        // Check all areas first, then check conflicts (conflict check also updates availability for selected area)
        // StateHasChanged() is called by CheckAllAreasAvailabilityAsync() and RecheckConflictsAsync()
        await CheckAllAreasAvailabilityAsync();
        await RecheckConflictsAsync();
    }

    private string AddMinutesToTime(string time, int minutes)
    {
        var parts = time.Split(':');
        var totalMinutes = int.Parse(parts[0]) * 60 + int.Parse(parts[1]) + minutes;
        var hours = totalMinutes / 60;
        var mins = totalMinutes % 60;
        
        // Handle day overflow
        if (hours >= 24)
        {
            hours = hours % 24;
        }
        
        return $"{hours:00}:{mins:00}";
    }
    
    private int GetDurationInMinutes(string startTime, string endTime)
    {
        var startParts = startTime.Split(':');
        var endParts = endTime.Split(':');
        var startMinutes = int.Parse(startParts[0]) * 60 + int.Parse(startParts[1]);
        var endMinutes = int.Parse(endParts[0]) * 60 + int.Parse(endParts[1]);
        
        // Handle day overflow
        if (endMinutes < startMinutes)
        {
            endMinutes += 24 * 60; // Add 24 hours
        }
        
        return endMinutes - startMinutes;
    }
    
    private List<string> GetTimeOptions()
    {
        var options = new List<string>();
        
        // Add 15-minute interval options
        for (var hour = 0; hour < 24; hour++)
        {
            for (var minute = 0; minute < 60; minute += 15)
            {
                options.Add($"{hour:00}:{minute:00}");
            }
        }
        
        // Add the calculated end time if it's not already in the list
        if (!string.IsNullOrEmpty(EndTime) && !options.Contains(EndTime))
        {
            options.Add(EndTime);
            options.Sort(); // Keep them sorted
        }
        
        return options;
    }

    private async Task OnDayCheckboxChanged(int day, object? value)
    {
        if (value is bool isChecked)
        {
            if (isChecked)
            {
                if (!SelectedDays.Contains(day))
                {
                    SelectedDays.Add(day);
                    // Initiera med nuvarande tider om dagen inte redan har tider
                    if (!DayTimes.ContainsKey(day))
                    {
                        DayTimes[day] = (StartTime, EndTime);
                    }
                }
            }
            else
            {
                SelectedDays.Remove(day);
                DayTimes.Remove(day);
            }
            // Check all areas first, then check conflicts (conflict check also updates availability for selected area)
            // StateHasChanged() is called by CheckAllAreasAvailabilityAsync() and RecheckConflictsAsync()
            await CheckAllAreasAvailabilityAsync();
            await RecheckConflictsAsync();
        }
    }
    
    // Hjälpmetod för att få sorterade valda dagar (1=Måndag, 2=Tisdag, etc.)
    private List<int> GetSortedSelectedDays()
    {
        return SelectedDays.OrderBy(d => d).ToList();
    }
    
    // Uppdatera starttid för en specifik dag - automatiskt uppdatera sluttid med samma logik som OnStartTimeChanged
    private async Task OnDayStartTimeChanged(int day, ChangeEventArgs e)
    {
        if (e.Value != null)
        {
            var newStartTime = e.Value.ToString()!;
            
            // Om dagen inte finns i DayTimes ännu, initiera den
            if (!DayTimes.ContainsKey(day))
            {
                DayTimes[day] = (StartTime, EndTime);
            }
            
            var (oldStartTime, oldEndTime) = DayTimes[day];
            
            // Beräkna nuvarande längd för denna dag
            var dayDuration = GetDurationInMinutes(oldStartTime, oldEndTime);
            
            // Uppdatera sluttiden med samma längd
            var newEndTime = AddMinutesToTime(newStartTime, dayDuration);
            
            DayTimes[day] = (newStartTime, newEndTime);
            StateHasChanged(); // Uppdatera UI först
            
            // Uppdatera konfliktkontroll när tider ändras
            await CheckAllAreasAvailabilityAsync();
            await RecheckConflictsAsync();
        }
    }
    
    // Uppdatera sluttid för en specifik dag - uppdatera duration (samma logik som OnEndTimeChanged)
    private async Task OnDayEndTimeChanged(int day, ChangeEventArgs e)
    {
        if (e.Value != null)
        {
            var newEndTime = e.Value.ToString()!;
            
            // Om dagen inte finns i DayTimes ännu, initiera den
            if (!DayTimes.ContainsKey(day))
            {
                DayTimes[day] = (StartTime, EndTime);
            }
            
            var (start, _) = DayTimes[day];
            DayTimes[day] = (start, newEndTime);
            StateHasChanged(); // Uppdatera UI först
            
            // Uppdatera konfliktkontroll när tider ändras
            await CheckAllAreasAvailabilityAsync();
            await RecheckConflictsAsync();
        }
    }
    
    private void TestButton()
    {
        // Console.WriteLine("=== TEST BUTTON CLICKED ===");
    }
    
    private async Task SaveBookingTemplate()
    {
        // CRITICAL: Check conflicts FIRST before doing anything
        await RecheckConflictsAsync();
        
        // Don't save if there are conflicts - show them to user
        if (hasConflicts)
        {
            Console.WriteLine("[BookingModal] Cannot save - conflicts detected");
            StateHasChanged();
            return;
        }

        // Disable button to prevent double-clicks during save
        var saveInProgress = true;
        StateHasChanged();

        try
        {
            // Get the selected area
            var targetArea = SelectedArea;
            if (SelectedAreaId.HasValue && AvailableAreas != null)
            {
                var selectedAreaFromList = AvailableAreas.FirstOrDefault(a => a.Id == SelectedAreaId.Value);
                if (selectedAreaFromList != null)
                {
                    targetArea = selectedAreaFromList;
                }
            }
            
            // Validate inputs
            if (!SelectedPlaceId.HasValue)
            {
                Console.WriteLine("[BookingModal] Error: No place selected");
                saveInProgress = false;
                StateHasChanged();
                return;
            }
            if (targetArea == null)
            {
                Console.WriteLine("[BookingModal] Error: No area selected");
                saveInProgress = false;
                StateHasChanged();
                return;
            }
            if (!SelectedGroupId.HasValue)
            {
                Console.WriteLine("[BookingModal] Error: No group selected");
                saveInProgress = false;
                StateHasChanged();
                return;
            }

            // Validate based on mode
            if (UI.IsCalendarViewMode)
            {
                if (SelectedDate == default)
                {
                    Console.WriteLine("[BookingModal] Error: No date selected");
                    saveInProgress = false;
                    StateHasChanged();
                    return;
                }
            }
            else
            {
                if (!UI.SelectedTemplateId.HasValue)
                {
                    Console.WriteLine("[BookingModal] Error: No template selected");
                    saveInProgress = false;
                    StateHasChanged();
                    return;
                }
                if (SelectedDays.Count == 0)
                {
                    Console.WriteLine("[BookingModal] Error: No days selected");
                    saveInProgress = false;
                    StateHasChanged();
                    return;
                }
            }

            await using var db = await DbFactory.CreateDbContextAsync();
            
            var startParts = StartTime.Split(':');
            var endParts = EndTime.Split(':');
            var startMin = int.Parse(startParts[0]) * 60 + int.Parse(startParts[1]);
            var endMin = int.Parse(endParts[0]) * 60 + int.Parse(endParts[1]);
            
            if (UI.IsCalendarViewMode)
            {
                // Calendar mode: Create calendar booking
                var calendarBooking = new CalendarBooking
                {
                    Id = Guid.NewGuid(),
                    Date = DateOnly.FromDateTime(SelectedDate),
                    AreaId = targetArea.Id,
                    GroupId = SelectedGroupId.Value,
                    StartMin = startMin,
                    EndMin = endMin,
                    Notes = string.IsNullOrWhiteSpace(Notes) ? null : Notes,
                    ContactName = ContactName,
                    ContactPhone = ContactPhone,
                    ContactEmail = ContactEmail
                };
                calendarBooking.CreatedAt = DateTime.UtcNow;

                db.CalendarBookings.Add(calendarBooking);
                // Console.WriteLine($"Created calendar booking for date {SelectedDate:yyyy-MM-dd}");
            }
            else
            {
                // Weekplanner mode: Create template bookings
                // Conflicts already checked above
                // CRITICAL: Create a copy to avoid "Collection was modified" errors during iteration
                var selectedDaysCopy = SelectedDays.ToList();
                foreach (var day in selectedDaysCopy)
                {
                    // Hämta tider för denna dag, eller använd standardtider
                    var (dayStartTime, dayEndTime) = DayTimes.ContainsKey(day) 
                        ? DayTimes[day] 
                        : (StartTime, EndTime);
                    
                    var dayStartParts = dayStartTime.Split(':');
                    var dayEndParts = dayEndTime.Split(':');
                    var dayStartMin = int.Parse(dayStartParts[0]) * 60 + int.Parse(dayStartParts[1]);
                    var dayEndMin = int.Parse(dayEndParts[0]) * 60 + int.Parse(dayEndParts[1]);
                    
                    // Normalize weekday into 1-7 (Mon-Sun)
                    var normalizedDay = day;
                    if (normalizedDay < 1) normalizedDay = 1;
                    if (normalizedDay > 7) normalizedDay = 7;
                    var template = new BookingTemplate
                    {
                        Id = Guid.NewGuid(),
                        ScheduleTemplateId = UI.SelectedTemplateId!.Value,
                        AreaId = targetArea.Id,
                        GroupId = SelectedGroupId.Value,
                        DayOfWeek = normalizedDay,
                        StartMin = dayStartMin,
                        EndMin = dayEndMin,
                        Notes = string.IsNullOrWhiteSpace(Notes) ? null : Notes,
                        ContactName = ContactName,
                        ContactPhone = ContactPhone,
                        ContactEmail = ContactEmail
                    };
                    template.CreatedAt = DateTime.UtcNow;

                    db.BookingTemplates.Add(template);
                    // Console.WriteLine($"Created booking template for weekday {normalizedDay} with time {dayStartTime}-{dayEndTime}");
                }
            }

            var result = await db.SaveChangesAsync();
            Console.WriteLine($"[BookingModal] Saved {result} booking(s) successfully");
            
            // Navigate to the selected place and area if different from current
            if (SelectedPlaceId.HasValue && SelectedPlaceId.Value != SelectedPlace?.Id)
            {
                UI.SelectedPlaceId = SelectedPlaceId.Value;
            }
            if (targetArea != null && targetArea.Id != SelectedArea?.Id)
            {
                UI.SelectedAreaId = targetArea.Id;
            }
            
            // Force WeekGrid to reload data to show new booking immediately
            UI.ForceRefresh = true;
            
            // Show success toast
            if (UI.IsCalendarViewMode)
            {
                ToastService.ShowSuccess("Bokning sparad", "Bokningen har sparats i kalendern");
            }
            else
            {
                ToastService.ShowSuccess("Bokning sparad", "Bokningen har lagts till i veckoschemat");
            }
            
            // Close modal
            await OnClose.InvokeAsync();
            
            // Trigger save callback
            await OnSave.InvokeAsync();
            
            // Refresh UI immediately - this will trigger WeekGrid to reload
            UI.RaiseChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[BookingModal] ERROR saving booking: {ex.Message}");
            Console.WriteLine($"[BookingModal] Stack trace: {ex.StackTrace}");
            saveInProgress = false;
            // Re-check conflicts in case something changed
            await RecheckConflictsAsync();
            StateHasChanged();
            // Don't re-throw - just show error and let user try again
        }
        finally
        {
            saveInProgress = false;
            StateHasChanged();
        }
    }

    private async Task RecheckConflictsAsync()
    {
        conflictMessages.Clear();
        hasConflicts = false;
        
        // Get the current area ID - use SelectedAreaId if available, otherwise SelectedArea parameter
        Guid? currentAreaId = null;
        if (SelectedAreaId.HasValue)
        {
            currentAreaId = SelectedAreaId.Value;
        }
        else if (SelectedArea != null)
        {
            currentAreaId = SelectedArea.Id;
        }
        
        if (!currentAreaId.HasValue) { StateHasChanged(); return; }

        // Parse times
        var sp = StartTime.Split(':'); var ep = EndTime.Split(':');
        var s = int.Parse(sp[0]) * 60 + int.Parse(sp[1]);
        var e = int.Parse(ep[0]) * 60 + int.Parse(ep[1]);

        if (UI.IsCalendarViewMode)
        {
            // Calendar: check conflicts for the selected date
            var conflicts = await ConflictService.CheckCalendarConflictsAsync(currentAreaId.Value, DateOnly.FromDateTime(SelectedDate), s, e, null);
            if (conflicts.Count > 0)
            {
                hasConflicts = true;
                foreach (var c in conflicts)
                {
                    var from = $"{c.StartMin/60:00}:{c.StartMin%60:00}"; var to = $"{c.EndMin/60:00}:{c.EndMin%60:00}";
                    conflictMessages.Add($"{GetDayName(c.DayOfWeek)} • {from}-{to} • {c.OtherAreaName} ({c.OtherGroupName})");
                }
            }
        }
        else
        {
            // Weekplanner: check per selected day within the current template only
            if (!UI.SelectedTemplateId.HasValue || SelectedDays.Count == 0) { StateHasChanged(); return; }
            // CRITICAL: Create a copy to avoid "Collection was modified" errors during iteration
            var selectedDaysCopy = SelectedDays.ToList();
            foreach (var d in selectedDaysCopy.OrderBy(d => d))
            {
                // Hämta tider för denna dag, eller använd standardtider
                var (dayStartTime, dayEndTime) = DayTimes.ContainsKey(d) 
                    ? DayTimes[d] 
                    : (StartTime, EndTime);
                
                var dayStartParts = dayStartTime.Split(':');
                var dayEndParts = dayEndTime.Split(':');
                var dayStartMin = int.Parse(dayStartParts[0]) * 60 + int.Parse(dayStartParts[1]);
                var dayEndMin = int.Parse(dayEndParts[0]) * 60 + int.Parse(dayEndParts[1]);
                
                var conflicts = await ConflictService.CheckAreaConflictsAsync(currentAreaId.Value, d, dayStartMin, dayEndMin, null, UI.SelectedTemplateId.Value);
                if (conflicts.Count > 0)
                {
                    hasConflicts = true;
                    var first = conflicts.First();
                    var from = $"{first.StartMin/60:00}:{first.StartMin%60:00}"; var to = $"{first.EndMin/60:00}:{first.EndMin%60:00}";
                    conflictMessages.Add($"{GetDayName(d)} • {from}-{to} • {first.OtherAreaName} ({first.OtherGroupName})");
                }
            }
        }
        
        // Update area availability indicator to match conflict status
        // This ensures the green/red indicator is always accurate and synced with conflict detection
        if (currentAreaId.HasValue)
        {
            AreaAvailability[currentAreaId.Value] = !hasConflicts;
        }
        
        StateHasChanged();
    }

    private void ToggleExtras()
    {
        showExtras = !showExtras;
        StateHasChanged();
    }
    
    private async Task CloseModal()
    {
        try
        {
            showAreaDropdown = false; // Close area dropdown when modal closes
            showPlaceDropdown = false; // Close place dropdown when modal closes
            
            // CRITICAL: Reset all fields when modal closes to prevent stale data on next open
            ResetAllFields();
            
            // Mark modal as closed so we know to reset on next open
            _wasOpen = false;
            
            await OnClose.InvokeAsync();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            // CRITICAL: Never throw from CloseModal - log and try to close anyway
            Console.WriteLine($"[BookingModal] Error in CloseModal: {ex.Message}");
            _wasOpen = false;
            try
            {
                await OnClose.InvokeAsync();
            }
            catch
            {
                // If OnClose fails, at least mark as closed
            }
        }
    }
    
    /// <summary>
    /// Resets all form fields to their default values to prevent stale data from showing
    /// when the modal is opened again. This eliminates the "blink" effect.
    /// CRITICAL: This method must never throw exceptions to prevent circuit crashes.
    /// </summary>
    private void ResetAllFields()
    {
        try
        {
            // Reset selection fields - ensure SelectedDays is initialized
            if (SelectedDays == null)
            {
                SelectedDays = new List<int>();
            }
            else
            {
                SelectedDays.Clear();
            }
            DayTimes.Clear();
            SelectedGroupId = null;
            SelectedPlaceId = null;
            SelectedAreaId = null;
            SelectedDate = DateTime.Today;
            
            // Reset time fields to defaults
            StartTime = "08:00";
            EndTime = "09:00";
            currentDurationMinutes = 60;
            
            // Reset contact/notes fields
            Notes = null;
            ContactName = null;
            ContactPhone = null;
            ContactEmail = null;
            showExtras = false;
            
            // Reset conflict/state fields
            hasConflicts = false;
            if (conflictMessages == null)
            {
                conflictMessages = new List<string>();
            }
            else
            {
                conflictMessages.Clear();
            }
            saveInProgress = false;
            
            // Reset UI state
            showAreaDropdown = false;
            showPlaceDropdown = false;
            if (AreaAvailability == null)
            {
                AreaAvailability = new Dictionary<Guid, bool>();
            }
            else
            {
                AreaAvailability.Clear();
            }
            
            // Note: We don't reset Groups, AvailablePlaces, AvailableAreas here
            // as they will be reloaded in OnParametersSetAsync anyway
        }
        catch (Exception ex)
        {
            // CRITICAL: Never throw from ResetAllFields - log and continue
            Console.WriteLine($"[BookingModal] Error in ResetAllFields: {ex.Message}");
        }
    }
    
    private string GetDayName(int day)
    {
        return day switch
        {
            1 => "Måndag",
            2 => "Tisdag",
            3 => "Onsdag",
            4 => "Torsdag",
            5 => "Fredag",
            6 => "Lördag",
            7 => "Söndag",
            _ => "Okänd"
        };
    }
    
    private DateTime GetWeekStart()
    {
        var today = DateTime.Today;
        var daysSinceMonday = (int)today.DayOfWeek - 1;
        if (daysSinceMonday == -1) daysSinceMonday = 6; // Sunday
        return today.AddDays(-daysSinceMonday);
    }
}
